# 0 "../py/compile.c"
# 1 "/home/neo/Documents/Code/NumWorks/Upsilon-External-KhiCAS-docker/apps/KhiCAS/src/micropython-1.12/numworks//"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "../py/compile.c"
# 27 "../py/compile.c"
# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stdbool.h" 1 3 4
# 28 "../py/compile.c" 2
# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stdint.h" 3 4
# 1 "/usr/arm-none-eabi/include/stdint.h" 1 3 4
# 12 "/usr/arm-none-eabi/include/stdint.h" 3 4
# 1 "/usr/arm-none-eabi/include/machine/_default_types.h" 1 3 4







# 1 "/usr/arm-none-eabi/include/sys/features.h" 1 3 4
# 28 "/usr/arm-none-eabi/include/sys/features.h" 3 4
# 1 "/usr/arm-none-eabi/include/_newlib_version.h" 1 3 4
# 29 "/usr/arm-none-eabi/include/sys/features.h" 2 3 4
# 9 "/usr/arm-none-eabi/include/machine/_default_types.h" 2 3 4
# 41 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4

# 41 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef signed char __int8_t;

typedef unsigned char __uint8_t;
# 55 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef short int __int16_t;

typedef short unsigned int __uint16_t;
# 77 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long int __int32_t;

typedef long unsigned int __uint32_t;
# 103 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long long int __int64_t;

typedef long long unsigned int __uint64_t;
# 134 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;
# 160 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;
# 182 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long int __int_least32_t;

typedef long unsigned int __uint_least32_t;
# 200 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long long int __int_least64_t;

typedef long long unsigned int __uint_least64_t;
# 214 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long long int __intmax_t;







typedef long long unsigned int __uintmax_t;







typedef int __intptr_t;

typedef unsigned int __uintptr_t;
# 13 "/usr/arm-none-eabi/include/stdint.h" 2 3 4
# 1 "/usr/arm-none-eabi/include/sys/_intsup.h" 1 3 4
# 35 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
       
       
       
       
       
       
       
       
# 190 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
       
       
       
       
       
       
       
       
# 14 "/usr/arm-none-eabi/include/stdint.h" 2 3 4
# 1 "/usr/arm-none-eabi/include/sys/_stdint.h" 1 3 4
# 20 "/usr/arm-none-eabi/include/sys/_stdint.h" 3 4
typedef __int8_t int8_t ;



typedef __uint8_t uint8_t ;







typedef __int16_t int16_t ;



typedef __uint16_t uint16_t ;







typedef __int32_t int32_t ;



typedef __uint32_t uint32_t ;







typedef __int64_t int64_t ;



typedef __uint64_t uint64_t ;






typedef __intmax_t intmax_t;




typedef __uintmax_t uintmax_t;




typedef __intptr_t intptr_t;




typedef __uintptr_t uintptr_t;
# 15 "/usr/arm-none-eabi/include/stdint.h" 2 3 4






typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;




typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;




typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;




typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;
# 51 "/usr/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast8_t;
  typedef unsigned int uint_fast8_t;
# 61 "/usr/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast16_t;
  typedef unsigned int uint_fast16_t;
# 71 "/usr/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 81 "/usr/arm-none-eabi/include/stdint.h" 3 4
  typedef long long int int_fast64_t;
  typedef long long unsigned int uint_fast64_t;
# 10 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stdint.h" 2 3 4
# 29 "../py/compile.c" 2
# 1 "/usr/arm-none-eabi/include/stdio.h" 1 3
# 29 "/usr/arm-none-eabi/include/stdio.h" 3
# 1 "/usr/arm-none-eabi/include/_ansi.h" 1 3
# 10 "/usr/arm-none-eabi/include/_ansi.h" 3
# 1 "/usr/arm-none-eabi/include/newlib.h" 1 3
# 11 "/usr/arm-none-eabi/include/_ansi.h" 2 3
# 1 "/usr/arm-none-eabi/include/sys/config.h" 1 3



# 1 "/usr/arm-none-eabi/include/machine/ieeefp.h" 1 3
# 5 "/usr/arm-none-eabi/include/sys/config.h" 2 3
# 12 "/usr/arm-none-eabi/include/_ansi.h" 2 3
# 30 "/usr/arm-none-eabi/include/stdio.h" 2 3





# 1 "/usr/arm-none-eabi/include/sys/cdefs.h" 1 3
# 47 "/usr/arm-none-eabi/include/sys/cdefs.h" 3
# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stddef.h" 1 3 4
# 214 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stddef.h" 3 4
typedef unsigned int size_t;
# 48 "/usr/arm-none-eabi/include/sys/cdefs.h" 2 3
# 36 "/usr/arm-none-eabi/include/stdio.h" 2 3
# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stddef.h" 1 3 4
# 145 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 329 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 37 "/usr/arm-none-eabi/include/stdio.h" 2 3



# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 41 "/usr/arm-none-eabi/include/stdio.h" 2 3





typedef __gnuc_va_list va_list;
# 60 "/usr/arm-none-eabi/include/stdio.h" 3
# 1 "/usr/arm-none-eabi/include/sys/reent.h" 1 3
# 13 "/usr/arm-none-eabi/include/sys/reent.h" 3
# 1 "/usr/arm-none-eabi/include/_ansi.h" 1 3
# 14 "/usr/arm-none-eabi/include/sys/reent.h" 2 3
# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stddef.h" 1 3 4
# 15 "/usr/arm-none-eabi/include/sys/reent.h" 2 3
# 1 "/usr/arm-none-eabi/include/sys/_types.h" 1 3
# 24 "/usr/arm-none-eabi/include/sys/_types.h" 3
# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stddef.h" 1 3 4
# 359 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 25 "/usr/arm-none-eabi/include/sys/_types.h" 2 3


# 1 "/usr/arm-none-eabi/include/machine/_types.h" 1 3
# 28 "/usr/arm-none-eabi/include/sys/_types.h" 2 3


typedef long __blkcnt_t;



typedef long __blksize_t;



typedef __uint64_t __fsblkcnt_t;



typedef __uint32_t __fsfilcnt_t;



typedef long _off_t;





typedef int __pid_t;



typedef short __dev_t;



typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



typedef __uint32_t __id_t;







typedef unsigned short __ino_t;
# 90 "/usr/arm-none-eabi/include/sys/_types.h" 3
typedef __uint32_t __mode_t;





__extension__ typedef long long _off64_t;





typedef _off_t __off_t;


typedef _off64_t __loff_t;


typedef long __key_t;







typedef long _fpos_t;
# 131 "/usr/arm-none-eabi/include/sys/_types.h" 3
typedef unsigned int __size_t;
# 147 "/usr/arm-none-eabi/include/sys/_types.h" 3
typedef signed int _ssize_t;
# 158 "/usr/arm-none-eabi/include/sys/_types.h" 3
typedef _ssize_t __ssize_t;



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;




typedef void *_iconv_t;






typedef unsigned long __clock_t;






typedef __int_least64_t __time_t;





typedef unsigned long __clockid_t;


typedef unsigned long __timer_t;


typedef __uint8_t __sa_family_t;



typedef __uint32_t __socklen_t;


typedef int __nl_item;
typedef unsigned short __nlink_t;
typedef long __suseconds_t;
typedef unsigned long __useconds_t;







typedef __builtin_va_list __va_list;
# 16 "/usr/arm-none-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 34 "/usr/arm-none-eabi/include/sys/reent.h" 3
# 1 "/usr/arm-none-eabi/include/sys/lock.h" 1 3
# 33 "/usr/arm-none-eabi/include/sys/lock.h" 3
struct __lock;
typedef struct __lock * _LOCK_T;






extern void __retarget_lock_init(_LOCK_T *lock);

extern void __retarget_lock_init_recursive(_LOCK_T *lock);

extern void __retarget_lock_close(_LOCK_T lock);

extern void __retarget_lock_close_recursive(_LOCK_T lock);

extern void __retarget_lock_acquire(_LOCK_T lock);

extern void __retarget_lock_acquire_recursive(_LOCK_T lock);

extern int __retarget_lock_try_acquire(_LOCK_T lock);

extern int __retarget_lock_try_acquire_recursive(_LOCK_T lock);


extern void __retarget_lock_release(_LOCK_T lock);

extern void __retarget_lock_release_recursive(_LOCK_T lock);
# 35 "/usr/arm-none-eabi/include/sys/reent.h" 2 3
typedef _LOCK_T _flock_t;







struct _reent;

struct __locale_t;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 98 "/usr/arm-none-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 122 "/usr/arm-none-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 186 "/usr/arm-none-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (*_read) (struct _reent *, void *,
        char *, int);
  int (*_write) (struct _reent *, void *,
         const char *,
         int);
  _fpos_t (*_seek) (struct _reent *, void *, _fpos_t, int);
  int (*_close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _off_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 292 "/usr/arm-none-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 324 "/usr/arm-none-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 613 "/usr/arm-none-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];


  int _unspecified_locale_info;
  struct __locale_t *_locale;

  int __sdidinit;

  void (*__cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;



  struct _atexit *_atexit;
  struct _atexit _atexit0;



  void (**_sig_func)(int);




  struct _glue __sglue;

  __FILE __sf[3];

};
# 819 "/usr/arm-none-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);
# 61 "/usr/arm-none-eabi/include/stdio.h" 2 3
# 1 "/usr/arm-none-eabi/include/sys/types.h" 1 3
# 28 "/usr/arm-none-eabi/include/sys/types.h" 3
typedef __uint8_t u_int8_t;


typedef __uint16_t u_int16_t;


typedef __uint32_t u_int32_t;


typedef __uint64_t u_int64_t;

typedef __intptr_t register_t;
# 49 "/usr/arm-none-eabi/include/sys/types.h" 3
# 1 "/usr/arm-none-eabi/include/machine/endian.h" 1 3





# 1 "/usr/arm-none-eabi/include/machine/_endian.h" 1 3
# 7 "/usr/arm-none-eabi/include/machine/endian.h" 2 3
# 50 "/usr/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/usr/arm-none-eabi/include/sys/select.h" 1 3
# 14 "/usr/arm-none-eabi/include/sys/select.h" 3
# 1 "/usr/arm-none-eabi/include/sys/_sigset.h" 1 3
# 41 "/usr/arm-none-eabi/include/sys/_sigset.h" 3
typedef unsigned long __sigset_t;
# 15 "/usr/arm-none-eabi/include/sys/select.h" 2 3
# 1 "/usr/arm-none-eabi/include/sys/_timeval.h" 1 3
# 37 "/usr/arm-none-eabi/include/sys/_timeval.h" 3
typedef __suseconds_t suseconds_t;




typedef __int_least64_t time_t;
# 54 "/usr/arm-none-eabi/include/sys/_timeval.h" 3
struct timeval {
 time_t tv_sec;
 suseconds_t tv_usec;
};
# 16 "/usr/arm-none-eabi/include/sys/select.h" 2 3
# 1 "/usr/arm-none-eabi/include/sys/timespec.h" 1 3
# 38 "/usr/arm-none-eabi/include/sys/timespec.h" 3
# 1 "/usr/arm-none-eabi/include/sys/_timespec.h" 1 3
# 47 "/usr/arm-none-eabi/include/sys/_timespec.h" 3
struct timespec {
 time_t tv_sec;
 long tv_nsec;
};
# 39 "/usr/arm-none-eabi/include/sys/timespec.h" 2 3
# 58 "/usr/arm-none-eabi/include/sys/timespec.h" 3
struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};
# 17 "/usr/arm-none-eabi/include/sys/select.h" 2 3



typedef __sigset_t sigset_t;
# 34 "/usr/arm-none-eabi/include/sys/select.h" 3
typedef unsigned long __fd_mask;

typedef __fd_mask fd_mask;
# 48 "/usr/arm-none-eabi/include/sys/select.h" 3
typedef struct fd_set {
 __fd_mask __fds_bits[(((64) + ((((int)sizeof(__fd_mask) * 8)) - 1)) / (((int)sizeof(__fd_mask) * 8)))];
} fd_set;
# 74 "/usr/arm-none-eabi/include/sys/select.h" 3


int select (int __n, fd_set *__readfds, fd_set *__writefds, fd_set *__exceptfds, struct timeval *__timeout)
                                                   ;

int pselect (int __n, fd_set *__readfds, fd_set *__writefds, fd_set *__exceptfds, const struct timespec *__timeout, const sigset_t *__set)

                           ;



# 51 "/usr/arm-none-eabi/include/sys/types.h" 2 3




typedef __uint32_t in_addr_t;




typedef __uint16_t in_port_t;



typedef __uintptr_t u_register_t;






typedef unsigned char u_char;



typedef unsigned short u_short;



typedef unsigned int u_int;



typedef unsigned long u_long;







typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;



typedef __blkcnt_t blkcnt_t;




typedef __blksize_t blksize_t;




typedef unsigned long clock_t;
# 119 "/usr/arm-none-eabi/include/sys/types.h" 3
typedef long daddr_t;



typedef char * caddr_t;




typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;




typedef __id_t id_t;




typedef __ino_t ino_t;
# 157 "/usr/arm-none-eabi/include/sys/types.h" 3
typedef __off_t off_t;



typedef __dev_t dev_t;



typedef __uid_t uid_t;



typedef __gid_t gid_t;




typedef __pid_t pid_t;




typedef __key_t key_t;




typedef _ssize_t ssize_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __clockid_t clockid_t;





typedef __timer_t timer_t;





typedef __useconds_t useconds_t;
# 220 "/usr/arm-none-eabi/include/sys/types.h" 3
typedef __int64_t sbintime_t;


# 1 "/usr/arm-none-eabi/include/sys/_pthreadtypes.h" 1 3
# 23 "/usr/arm-none-eabi/include/sys/_pthreadtypes.h" 3
# 1 "/usr/arm-none-eabi/include/sys/sched.h" 1 3
# 48 "/usr/arm-none-eabi/include/sys/sched.h" 3
struct sched_param {
  int sched_priority;
# 61 "/usr/arm-none-eabi/include/sys/sched.h" 3
};
# 24 "/usr/arm-none-eabi/include/sys/_pthreadtypes.h" 2 3
# 32 "/usr/arm-none-eabi/include/sys/_pthreadtypes.h" 3
typedef __uint32_t pthread_t;
# 61 "/usr/arm-none-eabi/include/sys/_pthreadtypes.h" 3
typedef struct {
  int is_initialized;
  void *stackaddr;
  int stacksize;
  int contentionscope;
  int inheritsched;
  int schedpolicy;
  struct sched_param schedparam;





  int detachstate;
} pthread_attr_t;
# 154 "/usr/arm-none-eabi/include/sys/_pthreadtypes.h" 3
typedef __uint32_t pthread_mutex_t;

typedef struct {
  int is_initialized;
# 168 "/usr/arm-none-eabi/include/sys/_pthreadtypes.h" 3
  int recursive;
} pthread_mutexattr_t;






typedef __uint32_t pthread_cond_t;



typedef struct {
  int is_initialized;
  clock_t clock;



} pthread_condattr_t;



typedef __uint32_t pthread_key_t;

typedef struct {
  int is_initialized;
  int init_executed;
} pthread_once_t;
# 224 "/usr/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/usr/arm-none-eabi/include/machine/types.h" 1 3
# 225 "/usr/arm-none-eabi/include/sys/types.h" 2 3
# 62 "/usr/arm-none-eabi/include/stdio.h" 2 3




typedef __FILE FILE;






typedef _fpos_t fpos_t;





# 1 "/usr/arm-none-eabi/include/sys/stdio.h" 1 3
# 80 "/usr/arm-none-eabi/include/stdio.h" 2 3
# 181 "/usr/arm-none-eabi/include/stdio.h" 3
char * ctermid (char *);




FILE * tmpfile (void);
char * tmpnam (char *);

char * tempnam (const char *, const char *) __attribute__((__malloc__)) __attribute__((__warn_unused_result__));

int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *restrict, const char *restrict, FILE *restrict);
void setbuf (FILE *restrict, char *restrict);
int setvbuf (FILE *restrict, char *restrict, int, size_t);
int fprintf (FILE *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int fscanf (FILE *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
int printf (const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 1, 2)));
int scanf (const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 1, 2)));
int sscanf (const char *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
int vfprintf (FILE *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int vprintf (const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 1, 0)));
int vsprintf (char *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int fgetc (FILE *);
char * fgets (char *restrict, int, FILE *restrict);
int fputc (int, FILE *);
int fputs (const char *restrict, FILE *restrict);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void *restrict, size_t _size, size_t _n, FILE *restrict);
size_t fwrite (const void *restrict , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *restrict, fpos_t *restrict);

int fseek (FILE *, long, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *restrict _name, const char *restrict _type);
int sprintf (char *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int remove (const char *);
int rename (const char *, const char *);
# 257 "/usr/arm-none-eabi/include/stdio.h" 3
int fseeko (FILE *, off_t, int);
off_t ftello (FILE *);







int snprintf (char *restrict, size_t, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int vsnprintf (char *restrict, size_t, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int vfscanf (FILE *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
int vscanf (const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 1, 0)));
int vsscanf (const char *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
# 284 "/usr/arm-none-eabi/include/stdio.h" 3
int asiprintf (char **, const char *, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
char * asniprintf (char *, size_t *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
char * asnprintf (char *restrict, size_t *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));

int diprintf (int, const char *, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));

int fiprintf (FILE *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int fiscanf (FILE *, const char *, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
int iprintf (const char *, ...)
               __attribute__ ((__format__ (__printf__, 1, 2)));
int iscanf (const char *, ...)
               __attribute__ ((__format__ (__scanf__, 1, 2)));
int siprintf (char *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int siscanf (const char *, const char *, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
int sniprintf (char *, size_t, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int vasiprintf (char **, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
char * vasniprintf (char *, size_t *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
char * vasnprintf (char *, size_t *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int vdiprintf (int, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int vfiprintf (FILE *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int vfiscanf (FILE *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
int viprintf (const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 1, 0)));
int viscanf (const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 1, 0)));
int vsiprintf (char *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int vsiscanf (const char *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
int vsniprintf (char *, size_t, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
# 339 "/usr/arm-none-eabi/include/stdio.h" 3
FILE * fdopen (int, const char *);

int fileno (FILE *);


int pclose (FILE *);
FILE * popen (const char *, const char *);



void setbuffer (FILE *, char *, int);
int setlinebuf (FILE *);



int getw (FILE *);
int putw (int, FILE *);


int getc_unlocked (FILE *);
int getchar_unlocked (void);
void flockfile (FILE *);
int ftrylockfile (FILE *);
void funlockfile (FILE *);
int putc_unlocked (int, FILE *);
int putchar_unlocked (int);
# 374 "/usr/arm-none-eabi/include/stdio.h" 3
int dprintf (int, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));

FILE * fmemopen (void *restrict, size_t, const char *restrict);


FILE * open_memstream (char **, size_t *);
int vdprintf (int, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));



int renameat (int, const char *, int, const char *);
# 396 "/usr/arm-none-eabi/include/stdio.h" 3
int _asiprintf_r (struct _reent *, char **, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
char * _asniprintf_r (struct _reent *, char *, size_t *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
char * _asnprintf_r (struct _reent *, char *restrict, size_t *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
int _asprintf_r (struct _reent *, char **restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _diprintf_r (struct _reent *, int, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _dprintf_r (struct _reent *, int, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _fclose_r (struct _reent *, FILE *);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
int _fflush_r (struct _reent *, FILE *);
int _fgetc_r (struct _reent *, FILE *);
int _fgetc_unlocked_r (struct _reent *, FILE *);
char * _fgets_r (struct _reent *, char *restrict, int, FILE *restrict);
char * _fgets_unlocked_r (struct _reent *, char *restrict, int, FILE *restrict);




int _fgetpos_r (struct _reent *, FILE *, fpos_t *);
int _fsetpos_r (struct _reent *, FILE *, const fpos_t *);

int _fiprintf_r (struct _reent *, FILE *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _fiscanf_r (struct _reent *, FILE *, const char *, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
FILE * _fmemopen_r (struct _reent *, void *restrict, size_t, const char *restrict);
FILE * _fopen_r (struct _reent *, const char *restrict, const char *restrict);
FILE * _freopen_r (struct _reent *, const char *restrict, const char *restrict, FILE *restrict);
int _fprintf_r (struct _reent *, FILE *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _fpurge_r (struct _reent *, FILE *);
int _fputc_r (struct _reent *, int, FILE *);
int _fputc_unlocked_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *restrict, FILE *restrict);
int _fputs_unlocked_r (struct _reent *, const char *restrict, FILE *restrict);
size_t _fread_r (struct _reent *, void *restrict, size_t _size, size_t _n, FILE *restrict);
size_t _fread_unlocked_r (struct _reent *, void *restrict, size_t _size, size_t _n, FILE *restrict);
int _fscanf_r (struct _reent *, FILE *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
int _fseek_r (struct _reent *, FILE *, long, int);
int _fseeko_r (struct _reent *, FILE *, _off_t, int);
long _ftell_r (struct _reent *, FILE *);
_off_t _ftello_r (struct _reent *, FILE *);
void _rewind_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void *restrict, size_t _size, size_t _n, FILE *restrict);
size_t _fwrite_unlocked_r (struct _reent *, const void *restrict, size_t _size, size_t _n, FILE *restrict);
int _getc_r (struct _reent *, FILE *);
int _getc_unlocked_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
int _getchar_unlocked_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int _iscanf_r (struct _reent *, const char *, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
FILE * _open_memstream_r (struct _reent *, char **, size_t *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int _putc_r (struct _reent *, int, FILE *);
int _putc_unlocked_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *,
      const char *_old, const char *_new);
int _scanf_r (struct _reent *, const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
int _siprintf_r (struct _reent *, char *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _siscanf_r (struct _reent *, const char *, const char *, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
int _snprintf_r (struct _reent *, char *restrict, size_t, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
int _sprintf_r (struct _reent *, char *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _sscanf_r (struct _reent *, const char *restrict, const char *restrict, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
char * _vasniprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
char * _vasnprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vdiprintf_r (struct _reent *, int, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vdprintf_r (struct _reent *, int, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));
int _vfprintf_r (struct _reent *, FILE *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vfscanf_r (struct _reent *, FILE *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));
int _viprintf_r (struct _reent *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int _viscanf_r (struct _reent *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
int _vprintf_r (struct _reent *, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int _vscanf_r (struct _reent *, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));
int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
int _vsnprintf_r (struct _reent *, char *restrict, size_t, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
int _vsprintf_r (struct _reent *, char *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vsscanf_r (struct _reent *, const char *restrict, const char *restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));



int fpurge (FILE *);
ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);


void clearerr_unlocked (FILE *);
int feof_unlocked (FILE *);
int ferror_unlocked (FILE *);
int fileno_unlocked (FILE *);
int fflush_unlocked (FILE *);
int fgetc_unlocked (FILE *);
int fputc_unlocked (int, FILE *);
size_t fread_unlocked (void *restrict, size_t _size, size_t _n, FILE *restrict);
size_t fwrite_unlocked (const void *restrict , size_t _size, size_t _n, FILE *);
# 577 "/usr/arm-none-eabi/include/stdio.h" 3
int __srget_r (struct _reent *, FILE *);
int __swbuf_r (struct _reent *, int, FILE *);
# 601 "/usr/arm-none-eabi/include/stdio.h" 3
FILE *funopen (const void *__cookie,
  int (*__readfn)(void *__cookie, char *__buf,
    int __n),
  int (*__writefn)(void *__cookie, const char *__buf,
     int __n),
  fpos_t (*__seekfn)(void *__cookie, fpos_t __off, int __whence),
  int (*__closefn)(void *__cookie));
FILE *_funopen_r (struct _reent *, const void *__cookie,
  int (*__readfn)(void *__cookie, char *__buf,
    int __n),
  int (*__writefn)(void *__cookie, const char *__buf,
     int __n),
  fpos_t (*__seekfn)(void *__cookie, fpos_t __off, int __whence),
  int (*__closefn)(void *__cookie));
# 687 "/usr/arm-none-eabi/include/stdio.h" 3
static __inline__ int __sputc_r(struct _reent *_ptr, int _c, FILE *_p) {




 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf_r(_ptr, _c, _p));
}
# 741 "/usr/arm-none-eabi/include/stdio.h" 3
static __inline int
_getchar_unlocked(void)
{
 struct _reent *_ptr;

 _ptr = _impure_ptr;
 return ((--(((_ptr)->_stdin))->_r < 0 ? __srget_r(_ptr, ((_ptr)->_stdin)) : (int)(*(((_ptr)->_stdin))->_p++)));
}

static __inline int
_putchar_unlocked(int _c)
{
 struct _reent *_ptr;

 _ptr = _impure_ptr;
 return (__sputc_r(_ptr, _c, ((_ptr)->_stdout)));
}
# 797 "/usr/arm-none-eabi/include/stdio.h" 3

# 30 "../py/compile.c" 2
# 1 "/usr/arm-none-eabi/include/string.h" 1 3
# 17 "/usr/arm-none-eabi/include/string.h" 3
# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stddef.h" 1 3 4
# 18 "/usr/arm-none-eabi/include/string.h" 2 3


# 1 "/usr/arm-none-eabi/include/sys/_locale.h" 1 3
# 9 "/usr/arm-none-eabi/include/sys/_locale.h" 3
struct __locale_t;
typedef struct __locale_t *locale_t;
# 21 "/usr/arm-none-eabi/include/string.h" 2 3



# 1 "/usr/arm-none-eabi/include/strings.h" 1 3
# 44 "/usr/arm-none-eabi/include/strings.h" 3


int bcmp(const void *, const void *, size_t) __attribute__((__pure__));
void bcopy(const void *, void *, size_t);
void bzero(void *, size_t);


void explicit_bzero(void *, size_t);


int ffs(int) __attribute__((__const__));


int ffsl(long) __attribute__((__const__));
int ffsll(long long) __attribute__((__const__));
int fls(int) __attribute__((__const__));
int flsl(long) __attribute__((__const__));
int flsll(long long) __attribute__((__const__));


char *index(const char *, int) __attribute__((__pure__));
char *rindex(const char *, int) __attribute__((__pure__));

int strcasecmp(const char *, const char *) __attribute__((__pure__));
int strncasecmp(const char *, const char *, size_t) __attribute__((__pure__));


int strcasecmp_l (const char *, const char *, locale_t);
int strncasecmp_l (const char *, const char *, size_t, locale_t);


# 25 "/usr/arm-none-eabi/include/string.h" 2 3




void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void *restrict, const void *restrict, size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *restrict, const char *restrict);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *restrict, const char *restrict);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *restrict, const char *restrict, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *restrict, const char *restrict, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);

char *strtok (char *restrict, const char *restrict);

size_t strxfrm (char *restrict, const char *restrict, size_t);


int strcoll_l (const char *, const char *, locale_t);
char *strerror_l (int, locale_t);
size_t strxfrm_l (char *restrict, const char *restrict, size_t, locale_t);


char *strtok_r (char *restrict, const char *restrict, char **restrict);


int timingsafe_bcmp (const void *, const void *, size_t);
int timingsafe_memcmp (const void *, const void *, size_t);


void * memccpy (void *restrict, const void *restrict, int, size_t);
# 76 "/usr/arm-none-eabi/include/string.h" 3
char *stpcpy (char *restrict, const char *restrict);
char *stpncpy (char *restrict, const char *restrict, size_t);






char *strdup (const char *) __attribute__((__malloc__)) __attribute__((__warn_unused_result__));

char *_strdup_r (struct _reent *, const char *);

char *strndup (const char *, size_t) __attribute__((__malloc__)) __attribute__((__warn_unused_result__));

char *_strndup_r (struct _reent *, const char *, size_t);
# 100 "/usr/arm-none-eabi/include/string.h" 3
int strerror_r (int, char *, size_t)

             __asm__ ("" "__xpg_strerror_r")

  ;







char * _strerror_r (struct _reent *, int, int, int *);


size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);


size_t strnlen (const char *, size_t);


char *strsep (char **, const char *);


char *strnstr(const char *, const char *, size_t) __attribute__((__pure__));



char *strlwr (char *);
char *strupr (char *);



char *strsignal (int __signo);
# 175 "/usr/arm-none-eabi/include/string.h" 3
# 1 "/usr/arm-none-eabi/include/sys/string.h" 1 3
# 176 "/usr/arm-none-eabi/include/string.h" 2 3


# 31 "../py/compile.c" 2
# 1 "/usr/arm-none-eabi/include/assert.h" 1 3
# 39 "/usr/arm-none-eabi/include/assert.h" 3
void __assert (const char *, int, const char *)
     __attribute__ ((__noreturn__));
void __assert_func (const char *, int, const char *, const char *)
     __attribute__ ((__noreturn__));
# 32 "../py/compile.c" 2

# 1 "../py/scope.h" 1
# 29 "../py/scope.h"
# 1 "../py/parse.h" 1
# 28 "../py/parse.h"

# 28 "../py/parse.h"
extern int parser_errorline,parser_errorcol;
# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stddef.h" 1 3 4
# 30 "../py/parse.h" 2


# 1 "../py/obj.h" 1
# 29 "../py/obj.h"
# 1 "../py/mpconfig.h" 1
# 62 "../py/mpconfig.h"
# 1 "./mpconfigport.h" 1
# 27 "./mpconfigport.h"
int micropython_port_vm_hook_loop() ;
# 101 "./mpconfigport.h"
int micropython_port_vm_hook_loop();




extern const struct _mp_obj_module_t mp_module_os;
extern const struct _mp_obj_module_t mp_module_nsp;
extern const struct _mp_obj_module_t mp_module_graphic;
extern const struct _mp_obj_module_t mp_module_cas;
extern const struct _mp_obj_module_t mp_module_arit;
extern const struct _mp_obj_module_t mp_module_turtle;
extern const struct _mp_obj_module_t mp_module_matplotl;
extern const struct _mp_obj_module_t mp_module_linalg;
extern const struct _mp_obj_module_t ulab_user_cmodule;
# 139 "./mpconfigport.h"
typedef int mp_int_t;
typedef unsigned int mp_uint_t;
typedef long mp_off_t;





typedef void *machine_ptr_t;
typedef const void *machine_const_ptr_t;





# 1 "/usr/arm-none-eabi/include/alloca.h" 1 3
# 155 "./mpconfigport.h" 2
# 63 "../py/mpconfig.h" 2
# 651 "../py/mpconfig.h"
typedef double mp_float_t;
# 30 "../py/obj.h" 2
# 1 "../py/misc.h" 1
# 35 "../py/misc.h"
# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include/stddef.h" 1 3 4
# 36 "../py/misc.h" 2

typedef unsigned char byte;
typedef unsigned int uint;
# 87 "../py/misc.h"
void *m_malloc(size_t num_bytes);
void *m_malloc_maybe(size_t num_bytes);
void *m_malloc_with_finaliser(size_t num_bytes);
void *m_malloc0(size_t num_bytes);

void *m_realloc(void *ptr, size_t old_num_bytes, size_t new_num_bytes);
void *m_realloc_maybe(void *ptr, size_t old_num_bytes, size_t new_num_bytes, 
# 93 "../py/misc.h" 3 4
                                                                            _Bool 
# 93 "../py/misc.h"
                                                                                 allow_move);
void m_free(void *ptr, size_t num_bytes);





__attribute__((noreturn)) void m_malloc_fail(size_t num_bytes);
# 120 "../py/misc.h"
typedef uint32_t unichar;







unichar utf8_get_char(const byte *s);
const byte *utf8_next_char(const byte *s);
size_t utf8_charlen(const byte *str, size_t len);







# 137 "../py/misc.h" 3 4
_Bool 
# 137 "../py/misc.h"
    unichar_isspace(unichar c);

# 138 "../py/misc.h" 3 4
_Bool 
# 138 "../py/misc.h"
    unichar_isalpha(unichar c);

# 139 "../py/misc.h" 3 4
_Bool 
# 139 "../py/misc.h"
    unichar_isprint(unichar c);

# 140 "../py/misc.h" 3 4
_Bool 
# 140 "../py/misc.h"
    unichar_isdigit(unichar c);

# 141 "../py/misc.h" 3 4
_Bool 
# 141 "../py/misc.h"
    unichar_isxdigit(unichar c);

# 142 "../py/misc.h" 3 4
_Bool 
# 142 "../py/misc.h"
    unichar_isident(unichar c);

# 143 "../py/misc.h" 3 4
_Bool 
# 143 "../py/misc.h"
    unichar_isupper(unichar c);

# 144 "../py/misc.h" 3 4
_Bool 
# 144 "../py/misc.h"
    unichar_islower(unichar c);
unichar unichar_tolower(unichar c);
unichar unichar_toupper(unichar c);
mp_uint_t unichar_xdigit_value(unichar c);





typedef struct _vstr_t {
    size_t alloc;
    size_t len;
    char *buf;
    
# 157 "../py/misc.h" 3 4
   _Bool 
# 157 "../py/misc.h"
        fixed_buf : 1;
} vstr_t;




void vstr_init(vstr_t *vstr, size_t alloc);
void vstr_init_len(vstr_t *vstr, size_t len);
void vstr_init_fixed_buf(vstr_t *vstr, size_t alloc, char *buf);
struct _mp_print_t;
void vstr_init_print(vstr_t *vstr, size_t alloc, struct _mp_print_t *print);
void vstr_clear(vstr_t *vstr);
vstr_t *vstr_new(size_t alloc);
void vstr_free(vstr_t *vstr);
static inline void vstr_reset(vstr_t *vstr) { vstr->len = 0; }
static inline char *vstr_str(vstr_t *vstr) { return vstr->buf; }
static inline size_t vstr_len(vstr_t *vstr) { return vstr->len; }
void vstr_hint_size(vstr_t *vstr, size_t size);
char *vstr_extend(vstr_t *vstr, size_t size);
char *vstr_add_len(vstr_t *vstr, size_t len);
char *vstr_null_terminated_str(vstr_t *vstr);
void vstr_add_byte(vstr_t *vstr, byte v);
void vstr_add_char(vstr_t *vstr, unichar chr);
void vstr_add_str(vstr_t *vstr, const char *str);
void vstr_add_strn(vstr_t *vstr, const char *str, size_t len);
void vstr_ins_byte(vstr_t *vstr, size_t byte_pos, byte b);
void vstr_ins_char(vstr_t *vstr, size_t char_pos, unichar chr);
void vstr_cut_head_bytes(vstr_t *vstr, size_t bytes_to_cut);
void vstr_cut_tail_bytes(vstr_t *vstr, size_t bytes_to_cut);
void vstr_cut_out_bytes(vstr_t *vstr, size_t byte_pos, size_t bytes_to_cut);
void vstr_printf(vstr_t *vstr, const char *fmt, ...);
# 206 "../py/misc.h"
int DEBUG_printf(const char *fmt, ...);

extern mp_uint_t mp_verbose_flag;
# 31 "../py/obj.h" 2
# 1 "../py/qstr.h" 1
# 39 "../py/qstr.h"
enum {





    MP_QSTRnumber_of,
};

typedef size_t qstr;

typedef struct _qstr_pool_t {
    struct _qstr_pool_t *prev;
    size_t total_prev_len;
    size_t alloc;
    size_t len;
    const byte *qstrs[];
} qstr_pool_t;




void qstr_init(void);

mp_uint_t qstr_compute_hash(const byte *data, size_t len);
qstr qstr_find_strn(const char *str, size_t str_len);

qstr qstr_from_str(const char *str);
qstr qstr_from_strn(const char *str, size_t len);

mp_uint_t qstr_hash(qstr q);
const char *qstr_str(qstr q);
size_t qstr_len(qstr q);
const byte *qstr_data(qstr q, size_t *len);

void qstr_pool_info(size_t *n_pool, size_t *n_qstr, size_t *n_str_data_bytes, size_t *n_total_bytes);
void qstr_dump_data(void);
# 32 "../py/obj.h" 2
# 1 "../py/mpprint.h" 1
# 48 "../py/mpprint.h"
typedef void (*mp_print_strn_t)(void *data, const char *str, size_t len);

typedef struct _mp_print_t {
    void *data;
    mp_print_strn_t print_strn;
} mp_print_t;



extern const mp_print_t mp_plat_print;


extern const mp_print_t mp_sys_stdout_print;


int mp_print_str(const mp_print_t *print, const char *str);
int mp_print_strn(const mp_print_t *print, const char *str, size_t len, int flags, char fill, int width);

int mp_print_float(const mp_print_t *print, mp_float_t f, char fmt, int flags, char fill, int width, int prec);


int mp_printf(const mp_print_t *print, const char *fmt, ...);
# 33 "../py/obj.h" 2
# 1 "../py/runtime0.h" 1
# 65 "../py/runtime0.h"
typedef enum {


    MP_UNARY_OP_POSITIVE,
    MP_UNARY_OP_NEGATIVE,
    MP_UNARY_OP_INVERT,
    MP_UNARY_OP_NOT,


    MP_UNARY_OP_BOOL,
    MP_UNARY_OP_LEN,
    MP_UNARY_OP_HASH,
    MP_UNARY_OP_ABS,
    MP_UNARY_OP_INT,
    MP_UNARY_OP_SIZEOF,
} mp_unary_op_t;

typedef enum {




    MP_BINARY_OP_LESS,
    MP_BINARY_OP_MORE,
    MP_BINARY_OP_EQUAL,
    MP_BINARY_OP_LESS_EQUAL,
    MP_BINARY_OP_MORE_EQUAL,
    MP_BINARY_OP_NOT_EQUAL,
    MP_BINARY_OP_IN,
    MP_BINARY_OP_IS,
    MP_BINARY_OP_EXCEPTION_MATCH,


    MP_BINARY_OP_INPLACE_OR,
    MP_BINARY_OP_INPLACE_XOR,
    MP_BINARY_OP_INPLACE_AND,
    MP_BINARY_OP_INPLACE_LSHIFT,
    MP_BINARY_OP_INPLACE_RSHIFT,
    MP_BINARY_OP_INPLACE_ADD,
    MP_BINARY_OP_INPLACE_SUBTRACT,
    MP_BINARY_OP_INPLACE_MULTIPLY,
    MP_BINARY_OP_INPLACE_MAT_MULTIPLY,
    MP_BINARY_OP_INPLACE_FLOOR_DIVIDE,
    MP_BINARY_OP_INPLACE_TRUE_DIVIDE,
    MP_BINARY_OP_INPLACE_MODULO,
    MP_BINARY_OP_INPLACE_POWER,


    MP_BINARY_OP_OR,
    MP_BINARY_OP_XOR,
    MP_BINARY_OP_AND,
    MP_BINARY_OP_LSHIFT,
    MP_BINARY_OP_RSHIFT,
    MP_BINARY_OP_ADD,
    MP_BINARY_OP_SUBTRACT,
    MP_BINARY_OP_MULTIPLY,
    MP_BINARY_OP_MAT_MULTIPLY,
    MP_BINARY_OP_FLOOR_DIVIDE,
    MP_BINARY_OP_TRUE_DIVIDE,
    MP_BINARY_OP_MODULO,
    MP_BINARY_OP_POWER,






    MP_BINARY_OP_DIVMOD,



    MP_BINARY_OP_CONTAINS,



    MP_BINARY_OP_REVERSE_OR,
    MP_BINARY_OP_REVERSE_XOR,
    MP_BINARY_OP_REVERSE_AND,
    MP_BINARY_OP_REVERSE_LSHIFT,
    MP_BINARY_OP_REVERSE_RSHIFT,
    MP_BINARY_OP_REVERSE_ADD,
    MP_BINARY_OP_REVERSE_SUBTRACT,
    MP_BINARY_OP_REVERSE_MULTIPLY,
    MP_BINARY_OP_REVERSE_MAT_MULTIPLY,
    MP_BINARY_OP_REVERSE_FLOOR_DIVIDE,
    MP_BINARY_OP_REVERSE_TRUE_DIVIDE,
    MP_BINARY_OP_REVERSE_MODULO,
    MP_BINARY_OP_REVERSE_POWER,


    MP_BINARY_OP_NOT_IN,
    MP_BINARY_OP_IS_NOT,
} mp_binary_op_t;
# 34 "../py/obj.h" 2
# 42 "../py/obj.h"
typedef void *mp_obj_t;
typedef const void *mp_const_obj_t;




typedef struct _mp_obj_type_t mp_obj_type_t;



struct _mp_obj_base_t {
    const mp_obj_type_t *type ;
};
typedef struct _mp_obj_base_t mp_obj_base_t;
# 84 "../py/obj.h"
static inline 
# 84 "../py/obj.h" 3 4
             _Bool 
# 84 "../py/obj.h"
                  mp_obj_is_small_int(mp_const_obj_t o)
    { return ((((mp_int_t)(o)) & 1) != 0); }



static inline 
# 89 "../py/obj.h" 3 4
             _Bool 
# 89 "../py/obj.h"
                  mp_obj_is_qstr(mp_const_obj_t o)
    { return ((((mp_int_t)(o)) & 3) == 2); }






extern const struct _mp_obj_float_t mp_const_float_e_obj;
extern const struct _mp_obj_float_t mp_const_float_pi_obj;


mp_float_t mp_obj_float_get(mp_obj_t self_in);
mp_obj_t mp_obj_new_float(mp_float_t value);


static inline 
# 105 "../py/obj.h" 3 4
             _Bool 
# 105 "../py/obj.h"
                  mp_obj_is_obj(mp_const_obj_t o)
    { return ((((mp_int_t)(o)) & 3) == 0); }
# 246 "../py/obj.h"
typedef mp_const_obj_t mp_rom_obj_t;
# 338 "../py/obj.h"
typedef struct _mp_map_elem_t {
    mp_obj_t key;
    mp_obj_t value;
} mp_map_elem_t;

typedef struct _mp_rom_map_elem_t {
    mp_rom_obj_t key;
    mp_rom_obj_t value;
} mp_rom_map_elem_t;






typedef struct _mp_map_t {
    size_t all_keys_are_qstrs : 1;
    size_t is_fixed : 1;
    size_t is_ordered : 1;
    size_t used : (8 * sizeof(size_t) - 3);
    size_t alloc;
    mp_map_elem_t *table;
} mp_map_t;


typedef enum _mp_map_lookup_kind_t {
    MP_MAP_LOOKUP = 0,
    MP_MAP_LOOKUP_ADD_IF_NOT_FOUND = 1,
    MP_MAP_LOOKUP_REMOVE_IF_FOUND = 2,
    MP_MAP_LOOKUP_ADD_IF_NOT_FOUND_OR_REMOVE_IF_FOUND = 3,
} mp_map_lookup_kind_t;

extern const mp_map_t mp_const_empty_map;

static inline 
# 372 "../py/obj.h" 3 4
             _Bool 
# 372 "../py/obj.h"
                  mp_map_slot_is_filled(const mp_map_t *map, size_t pos) { return ((map)->table[pos].key != (((mp_obj_t)(void*)0)) && (map)->table[pos].key != (((mp_obj_t)(void*)4))); }

void mp_map_init(mp_map_t *map, size_t n);
void mp_map_init_fixed_table(mp_map_t *map, size_t n, const mp_obj_t *table);
mp_map_t *mp_map_new(size_t n);
void mp_map_deinit(mp_map_t *map);
void mp_map_free(mp_map_t *map);
mp_map_elem_t *mp_map_lookup(mp_map_t *map, mp_obj_t index, mp_map_lookup_kind_t lookup_kind);
void mp_map_clear(mp_map_t *map);
void mp_map_dump(mp_map_t *map);



typedef struct _mp_set_t {
    size_t alloc;
    size_t used;
    mp_obj_t *table;
} mp_set_t;

static inline 
# 391 "../py/obj.h" 3 4
             _Bool 
# 391 "../py/obj.h"
                  mp_set_slot_is_filled(const mp_set_t *set, size_t pos) { return ((set)->table[pos] != (((mp_obj_t)(void*)0)) && (set)->table[pos] != (((mp_obj_t)(void*)4))); }

void mp_set_init(mp_set_t *set, size_t n);
mp_obj_t mp_set_lookup(mp_set_t *set, mp_obj_t index, mp_map_lookup_kind_t lookup_kind);
mp_obj_t mp_set_remove_first(mp_set_t *set);
void mp_set_clear(mp_set_t *set);



typedef mp_obj_t (*mp_fun_0_t)(void);
typedef mp_obj_t (*mp_fun_1_t)(mp_obj_t);
typedef mp_obj_t (*mp_fun_2_t)(mp_obj_t, mp_obj_t);
typedef mp_obj_t (*mp_fun_3_t)(mp_obj_t, mp_obj_t, mp_obj_t);
typedef mp_obj_t (*mp_fun_var_t)(size_t n, const mp_obj_t *);


typedef mp_obj_t (*mp_fun_kw_t)(size_t n, const mp_obj_t *, mp_map_t *);

typedef enum {
    PRINT_STR = 0,
    PRINT_REPR = 1,
    PRINT_EXC = 2,
    PRINT_JSON = 3,
    PRINT_RAW = 4,
    PRINT_EXC_SUBCLASS = 0x80,
} mp_print_kind_t;

typedef struct _mp_obj_iter_buf_t {
    mp_obj_base_t base;
    mp_obj_t buf[3];
} mp_obj_iter_buf_t;





typedef void (*mp_print_fun_t)(const mp_print_t *print, mp_obj_t o, mp_print_kind_t kind);
typedef mp_obj_t (*mp_make_new_fun_t)(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args);
typedef mp_obj_t (*mp_call_fun_t)(mp_obj_t fun, size_t n_args, size_t n_kw, const mp_obj_t *args);
typedef mp_obj_t (*mp_unary_op_fun_t)(mp_unary_op_t op, mp_obj_t);
typedef mp_obj_t (*mp_binary_op_fun_t)(mp_binary_op_t op, mp_obj_t, mp_obj_t);
typedef void (*mp_attr_fun_t)(mp_obj_t self_in, qstr attr, mp_obj_t *dest);
typedef mp_obj_t (*mp_subscr_fun_t)(mp_obj_t self_in, mp_obj_t index, mp_obj_t value);
typedef mp_obj_t (*mp_getiter_fun_t)(mp_obj_t self_in, mp_obj_iter_buf_t *iter_buf);


typedef struct _mp_buffer_info_t {





    void *buf;
    size_t len;
    int typecode;




} mp_buffer_info_t;



typedef struct _mp_buffer_p_t {
    mp_int_t (*get_buffer)(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags);
} mp_buffer_p_t;

# 457 "../py/obj.h" 3 4
_Bool 
# 457 "../py/obj.h"
    mp_get_buffer(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags);
void mp_get_buffer_raise(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags);

struct _mp_obj_type_t {

    mp_obj_base_t base;


    uint16_t flags;


    uint16_t name;


    mp_print_fun_t print;


    mp_make_new_fun_t make_new;


    mp_call_fun_t call;



    mp_unary_op_fun_t unary_op;
    mp_binary_op_fun_t binary_op;
# 495 "../py/obj.h"
    mp_attr_fun_t attr;






    mp_subscr_fun_t subscr;




    mp_getiter_fun_t getiter;



    mp_fun_1_t iternext;


    mp_buffer_p_t buffer_p;


    const void *protocol;





    const void *parent;


    struct _mp_obj_dict_t *locals_dict;
};


extern const mp_obj_type_t mp_type_type;
extern const mp_obj_type_t mp_type_object;
extern const mp_obj_type_t mp_type_NoneType;
extern const mp_obj_type_t mp_type_bool;
extern const mp_obj_type_t mp_type_int;
extern const mp_obj_type_t mp_type_str;
extern const mp_obj_type_t mp_type_bytes;
extern const mp_obj_type_t mp_type_bytearray;
extern const mp_obj_type_t mp_type_memoryview;
extern const mp_obj_type_t mp_type_float;
extern const mp_obj_type_t mp_type_complex;
extern const mp_obj_type_t mp_type_tuple;
extern const mp_obj_type_t mp_type_list;
extern const mp_obj_type_t mp_type_map;
extern const mp_obj_type_t mp_type_enumerate;
extern const mp_obj_type_t mp_type_filter;
extern const mp_obj_type_t mp_type_deque;
extern const mp_obj_type_t mp_type_dict;
extern const mp_obj_type_t mp_type_ordereddict;
extern const mp_obj_type_t mp_type_range;
extern const mp_obj_type_t mp_type_set;
extern const mp_obj_type_t mp_type_frozenset;
extern const mp_obj_type_t mp_type_slice;
extern const mp_obj_type_t mp_type_zip;
extern const mp_obj_type_t mp_type_array;
extern const mp_obj_type_t mp_type_super;
extern const mp_obj_type_t mp_type_gen_wrap;
extern const mp_obj_type_t mp_type_native_gen_wrap;
extern const mp_obj_type_t mp_type_gen_instance;
extern const mp_obj_type_t mp_type_fun_builtin_0;
extern const mp_obj_type_t mp_type_fun_builtin_1;
extern const mp_obj_type_t mp_type_fun_builtin_2;
extern const mp_obj_type_t mp_type_fun_builtin_3;
extern const mp_obj_type_t mp_type_fun_builtin_var;
extern const mp_obj_type_t mp_type_fun_bc;
extern const mp_obj_type_t mp_type_module;
extern const mp_obj_type_t mp_type_staticmethod;
extern const mp_obj_type_t mp_type_classmethod;
extern const mp_obj_type_t mp_type_property;
extern const mp_obj_type_t mp_type_stringio;
extern const mp_obj_type_t mp_type_bytesio;
extern const mp_obj_type_t mp_type_reversed;
extern const mp_obj_type_t mp_type_polymorph_iter;


extern const mp_obj_type_t mp_type_BaseException;
extern const mp_obj_type_t mp_type_ArithmeticError;
extern const mp_obj_type_t mp_type_AssertionError;
extern const mp_obj_type_t mp_type_AttributeError;
extern const mp_obj_type_t mp_type_EOFError;
extern const mp_obj_type_t mp_type_Exception;
extern const mp_obj_type_t mp_type_GeneratorExit;
extern const mp_obj_type_t mp_type_ImportError;
extern const mp_obj_type_t mp_type_IndentationError;
extern const mp_obj_type_t mp_type_IndexError;
extern const mp_obj_type_t mp_type_KeyboardInterrupt;
extern const mp_obj_type_t mp_type_KeyError;
extern const mp_obj_type_t mp_type_LookupError;
extern const mp_obj_type_t mp_type_MemoryError;
extern const mp_obj_type_t mp_type_NameError;
extern const mp_obj_type_t mp_type_NotImplementedError;
extern const mp_obj_type_t mp_type_OSError;
extern const mp_obj_type_t mp_type_TimeoutError;
extern const mp_obj_type_t mp_type_OverflowError;
extern const mp_obj_type_t mp_type_RuntimeError;
extern const mp_obj_type_t mp_type_StopAsyncIteration;
extern const mp_obj_type_t mp_type_StopIteration;
extern const mp_obj_type_t mp_type_SyntaxError;
extern const mp_obj_type_t mp_type_SystemExit;
extern const mp_obj_type_t mp_type_TypeError;
extern const mp_obj_type_t mp_type_UnicodeError;
extern const mp_obj_type_t mp_type_ValueError;
extern const mp_obj_type_t mp_type_ViperTypeError;
extern const mp_obj_type_t mp_type_ZeroDivisionError;
# 613 "../py/obj.h"
extern const struct _mp_obj_none_t mp_const_none_obj;
extern const struct _mp_obj_bool_t mp_const_false_obj;
extern const struct _mp_obj_bool_t mp_const_true_obj;
extern const struct _mp_obj_str_t mp_const_empty_bytes_obj;
extern const struct _mp_obj_tuple_t mp_const_empty_tuple_obj;
extern const struct _mp_obj_singleton_t mp_const_ellipsis_obj;
extern const struct _mp_obj_singleton_t mp_const_notimplemented_obj;
extern const struct _mp_obj_exception_t mp_const_GeneratorExit_obj;
# 634 "../py/obj.h"
mp_obj_t mp_obj_new_type(qstr name, mp_obj_t bases_tuple, mp_obj_t locals_dict);
static inline mp_obj_t mp_obj_new_bool(mp_int_t x) { return x ? (((mp_obj_t)&mp_const_true_obj)) : (((mp_obj_t)&mp_const_false_obj)); }
mp_obj_t mp_obj_new_cell(mp_obj_t obj);
mp_obj_t mp_obj_new_int(mp_int_t value);
mp_obj_t mp_obj_new_int_from_uint(mp_uint_t value);
mp_obj_t mp_obj_new_int_from_str_len(const char **str, size_t len, 
# 639 "../py/obj.h" 3 4
                                                                  _Bool 
# 639 "../py/obj.h"
                                                                       neg, unsigned int base);
mp_obj_t mp_obj_new_int_from_ll(long long val);
mp_obj_t mp_obj_new_int_from_ull(unsigned long long val);
mp_obj_t mp_obj_new_str(const char* data, size_t len);
mp_obj_t mp_obj_new_str_via_qstr(const char* data, size_t len);
mp_obj_t mp_obj_new_str_from_vstr(const mp_obj_type_t *type, vstr_t *vstr);
mp_obj_t mp_obj_new_bytes(const byte* data, size_t len);
mp_obj_t mp_obj_new_bytearray(size_t n, void *items);
mp_obj_t mp_obj_new_bytearray_by_ref(size_t n, void *items);

mp_obj_t mp_obj_new_int_from_float(mp_float_t val);
mp_obj_t mp_obj_new_complex(mp_float_t real, mp_float_t imag);

mp_obj_t mp_obj_new_exception(const mp_obj_type_t *exc_type);
mp_obj_t mp_obj_new_exception_arg1(const mp_obj_type_t *exc_type, mp_obj_t arg);
mp_obj_t mp_obj_new_exception_args(const mp_obj_type_t *exc_type, size_t n_args, const mp_obj_t *args);
mp_obj_t mp_obj_new_exception_msg(const mp_obj_type_t *exc_type, const char *msg);
mp_obj_t mp_obj_new_exception_msg_varg(const mp_obj_type_t *exc_type, const char *fmt, ...);
mp_obj_t mp_obj_new_fun_bc(mp_obj_t def_args, mp_obj_t def_kw_args, const byte *code, const mp_uint_t *const_table);
mp_obj_t mp_obj_new_fun_native(mp_obj_t def_args_in, mp_obj_t def_kw_args, const void *fun_data, const mp_uint_t *const_table);
mp_obj_t mp_obj_new_fun_asm(size_t n_args, const void *fun_data, mp_uint_t type_sig);
mp_obj_t mp_obj_new_gen_wrap(mp_obj_t fun);
mp_obj_t mp_obj_new_closure(mp_obj_t fun, size_t n_closed, const mp_obj_t *closed);
mp_obj_t mp_obj_new_tuple(size_t n, const mp_obj_t *items);
mp_obj_t mp_obj_new_list(size_t n, mp_obj_t *items);
mp_obj_t mp_obj_new_dict(size_t n_args);
mp_obj_t mp_obj_new_set(size_t n_args, mp_obj_t *items);
mp_obj_t mp_obj_new_slice(mp_obj_t start, mp_obj_t stop, mp_obj_t step);
mp_obj_t mp_obj_new_bound_meth(mp_obj_t meth, mp_obj_t self);
mp_obj_t mp_obj_new_getitem_iter(mp_obj_t *args, mp_obj_iter_buf_t *iter_buf);
mp_obj_t mp_obj_new_module(qstr module_name);
mp_obj_t mp_obj_new_memoryview(byte typecode, size_t nitems, void *items);

mp_obj_type_t *mp_obj_get_type(mp_const_obj_t o_in);
const char *mp_obj_get_type_str(mp_const_obj_t o_in);

# 674 "../py/obj.h" 3 4
_Bool 
# 674 "../py/obj.h"
    mp_obj_is_subclass_fast(mp_const_obj_t object, mp_const_obj_t classinfo);
mp_obj_t mp_instance_cast_to_native_base(mp_const_obj_t self_in, mp_const_obj_t native_type);

void mp_obj_print_helper(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind);
void mp_obj_print(mp_obj_t o, mp_print_kind_t kind);
void mp_obj_print_exception(const mp_print_t *print, mp_obj_t exc);


# 681 "../py/obj.h" 3 4
_Bool 
# 681 "../py/obj.h"
    mp_obj_is_true(mp_obj_t arg);

# 682 "../py/obj.h" 3 4
_Bool 
# 682 "../py/obj.h"
    mp_obj_is_callable(mp_obj_t o_in);

# 683 "../py/obj.h" 3 4
_Bool 
# 683 "../py/obj.h"
    mp_obj_equal(mp_obj_t o1, mp_obj_t o2);

static inline 
# 685 "../py/obj.h" 3 4
             _Bool 
# 685 "../py/obj.h"
                  mp_obj_is_integer(mp_const_obj_t o) { return (mp_obj_is_small_int(o) || (mp_obj_is_obj(o) && (((mp_obj_base_t*)((void*)o))->type == (&mp_type_int)))) || (mp_obj_is_obj(o) && (((mp_obj_base_t*)((void*)o))->type == (&mp_type_bool))); }
mp_int_t mp_obj_get_int(mp_const_obj_t arg);
mp_int_t mp_obj_get_int_truncated(mp_const_obj_t arg);

# 688 "../py/obj.h" 3 4
_Bool 
# 688 "../py/obj.h"
    mp_obj_get_int_maybe(mp_const_obj_t arg, mp_int_t *value);

mp_float_t mp_obj_get_float(mp_obj_t self_in);

# 691 "../py/obj.h" 3 4
_Bool 
# 691 "../py/obj.h"
    mp_obj_get_float_maybe(mp_obj_t arg, mp_float_t *value);
void mp_obj_get_complex(mp_obj_t self_in, mp_float_t *real, mp_float_t *imag);

void mp_obj_get_array(mp_obj_t o, size_t *len, mp_obj_t **items);
void mp_obj_get_array_fixed_n(mp_obj_t o, size_t len, mp_obj_t **items);
size_t mp_get_index(const mp_obj_type_t *type, size_t len, mp_obj_t index, 
# 696 "../py/obj.h" 3 4
                                                                          _Bool 
# 696 "../py/obj.h"
                                                                               is_slice);
mp_obj_t mp_obj_id(mp_obj_t o_in);
mp_obj_t mp_obj_len(mp_obj_t o_in);
mp_obj_t mp_obj_len_maybe(mp_obj_t o_in);
mp_obj_t mp_obj_subscr(mp_obj_t base, mp_obj_t index, mp_obj_t val);
mp_obj_t mp_generic_unary_op(mp_unary_op_t op, mp_obj_t o_in);


mp_obj_t mp_obj_cell_get(mp_obj_t self_in);
void mp_obj_cell_set(mp_obj_t self_in, mp_obj_t obj);



mp_int_t mp_obj_int_get_truncated(mp_const_obj_t self_in);

mp_int_t mp_obj_int_get_checked(mp_const_obj_t self_in);




# 715 "../py/obj.h" 3 4
_Bool 
# 715 "../py/obj.h"
    mp_obj_is_exception_type(mp_obj_t self_in);

# 716 "../py/obj.h" 3 4
_Bool 
# 716 "../py/obj.h"
    mp_obj_is_exception_instance(mp_obj_t self_in);

# 717 "../py/obj.h" 3 4
_Bool 
# 717 "../py/obj.h"
    mp_obj_exception_match(mp_obj_t exc, mp_const_obj_t exc_type);
void mp_obj_exception_clear_traceback(mp_obj_t self_in);
void mp_obj_exception_add_traceback(mp_obj_t self_in, qstr file, size_t line, qstr block);
void mp_obj_exception_get_traceback(mp_obj_t self_in, size_t *n, size_t **values);
mp_obj_t mp_obj_exception_get_value(mp_obj_t self_in);
mp_obj_t mp_obj_exception_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args);
mp_obj_t mp_alloc_emergency_exception_buf(mp_obj_t size_in);
void mp_init_emergency_exception_buf(void);



# 727 "../py/obj.h" 3 4
_Bool 
# 727 "../py/obj.h"
    mp_obj_str_equal(mp_obj_t s1, mp_obj_t s2);
qstr mp_obj_str_get_qstr(mp_obj_t self_in);
const char *mp_obj_str_get_str(mp_obj_t self_in);
const char *mp_obj_str_get_data(mp_obj_t self_in, size_t *len);
mp_obj_t mp_obj_str_intern(mp_obj_t str);
mp_obj_t mp_obj_str_intern_checked(mp_obj_t obj);
void mp_str_print_quoted(const mp_print_t *print, const byte *str_data, size_t str_len, 
# 733 "../py/obj.h" 3 4
                                                                                       _Bool 
# 733 "../py/obj.h"
                                                                                            is_bytes);






static inline mp_int_t mp_float_hash(mp_float_t val) { return (mp_int_t)val; }

mp_obj_t mp_obj_float_binary_op(mp_binary_op_t op, mp_float_t lhs_val, mp_obj_t rhs);


void mp_obj_complex_get(mp_obj_t self_in, mp_float_t *real, mp_float_t *imag);
mp_obj_t mp_obj_complex_binary_op(mp_binary_op_t op, mp_float_t lhs_real, mp_float_t lhs_imag, mp_obj_t rhs_in);





void mp_obj_tuple_get(mp_obj_t self_in, size_t *len, mp_obj_t **items);
void mp_obj_tuple_del(mp_obj_t self_in);
mp_int_t mp_obj_tuple_hash(mp_obj_t self_in);


mp_obj_t mp_obj_list_append(mp_obj_t self_in, mp_obj_t arg);
mp_obj_t mp_obj_list_remove(mp_obj_t self_in, mp_obj_t value);
void mp_obj_list_get(mp_obj_t self_in, size_t *len, mp_obj_t **items);
void mp_obj_list_set_len(mp_obj_t self_in, size_t len);
void mp_obj_list_store(mp_obj_t self_in, mp_obj_t index, mp_obj_t value);
mp_obj_t mp_obj_list_sort(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs);


typedef struct _mp_obj_dict_t {
    mp_obj_base_t base;
    mp_map_t map;
} mp_obj_dict_t;
void mp_obj_dict_init(mp_obj_dict_t *dict, size_t n_args);
size_t mp_obj_dict_len(mp_obj_t self_in);
mp_obj_t mp_obj_dict_get(mp_obj_t self_in, mp_obj_t index);
mp_obj_t mp_obj_dict_store(mp_obj_t self_in, mp_obj_t key, mp_obj_t value);
mp_obj_t mp_obj_dict_delete(mp_obj_t self_in, mp_obj_t key);
static inline mp_map_t *mp_obj_dict_get_map(mp_obj_t dict) {
    return &((mp_obj_dict_t*)((void*)dict))->map;
}


void mp_obj_set_store(mp_obj_t self_in, mp_obj_t item);


void mp_obj_slice_get(mp_obj_t self_in, mp_obj_t *start, mp_obj_t *stop, mp_obj_t *step);



typedef struct _mp_obj_fun_builtin_fixed_t {
    mp_obj_base_t base;
    union {
        mp_fun_0_t _0;
        mp_fun_1_t _1;
        mp_fun_2_t _2;
        mp_fun_3_t _3;
    } fun;
} mp_obj_fun_builtin_fixed_t;

typedef struct _mp_obj_fun_builtin_var_t {
    mp_obj_base_t base;
    uint32_t sig;
    union {
        mp_fun_var_t var;
        mp_fun_kw_t kw;
    } fun;
} mp_obj_fun_builtin_var_t;

qstr mp_obj_fun_get_name(mp_const_obj_t fun);
qstr mp_obj_code_get_name(const byte *code_info);

mp_obj_t mp_identity(mp_obj_t self);
extern const mp_obj_fun_builtin_fixed_t mp_identity_obj;
mp_obj_t mp_identity_getiter(mp_obj_t self, mp_obj_iter_buf_t *iter_buf);


typedef struct _mp_obj_module_t {
    mp_obj_base_t base;
    mp_obj_dict_t *globals;
} mp_obj_module_t;
static inline mp_obj_dict_t *mp_obj_module_get_globals(mp_obj_t module) {
    return ((mp_obj_module_t*)((void*)module))->globals;
}


# 821 "../py/obj.h" 3 4
_Bool 
# 821 "../py/obj.h"
    mp_obj_is_package(mp_obj_t module);



typedef struct _mp_obj_static_class_method_t {
    mp_obj_base_t base;
    mp_obj_t fun;
} mp_obj_static_class_method_t;
typedef struct _mp_rom_obj_static_class_method_t {
    mp_obj_base_t base;
    mp_rom_obj_t fun;
} mp_rom_obj_static_class_method_t;


const mp_obj_t *mp_obj_property_get(mp_obj_t self_in);




typedef struct {
    mp_uint_t start;
    mp_uint_t stop;
    mp_int_t step;
} mp_bound_slice_t;

void mp_seq_multiply(const void *items, size_t item_sz, size_t len, size_t times, void *dest);


# 848 "../py/obj.h" 3 4
_Bool 
# 848 "../py/obj.h"
    mp_seq_get_fast_slice_indexes(mp_uint_t len, mp_obj_t slice, mp_bound_slice_t *indexes);




# 852 "../py/obj.h" 3 4
_Bool 
# 852 "../py/obj.h"
    mp_seq_cmp_bytes(mp_uint_t op, const byte *data1, size_t len1, const byte *data2, size_t len2);

# 853 "../py/obj.h" 3 4
_Bool 
# 853 "../py/obj.h"
    mp_seq_cmp_objs(mp_uint_t op, const mp_obj_t *items1, size_t len1, const mp_obj_t *items2, size_t len2);
mp_obj_t mp_seq_index_obj(const mp_obj_t *items, size_t len, size_t n_args, const mp_obj_t *args);
mp_obj_t mp_seq_count_obj(const mp_obj_t *items, size_t len, mp_obj_t value);
mp_obj_t mp_seq_extract_slice(size_t len, const mp_obj_t *seq, mp_bound_slice_t *indexes);
# 33 "../py/parse.h" 2

struct _mp_lexer_t;
# 52 "../py/parse.h"
typedef uintptr_t mp_parse_node_t;

typedef struct _mp_parse_node_struct_t {
    uint32_t source_line;
    uint32_t kind_num_nodes;
    mp_parse_node_t nodes[];
} mp_parse_node_struct_t;
# 79 "../py/parse.h"
static inline mp_parse_node_t mp_parse_node_new_small_int(mp_int_t val) {
    return (mp_parse_node_t)((0x1) | ((mp_uint_t)val << 1));
}
static inline mp_parse_node_t mp_parse_node_new_leaf(size_t kind, mp_int_t arg) {
    return (mp_parse_node_t)(kind | ((mp_uint_t)arg << 4));
}

# 85 "../py/parse.h" 3 4
_Bool 
# 85 "../py/parse.h"
    mp_parse_node_is_const_false(mp_parse_node_t pn);

# 86 "../py/parse.h" 3 4
_Bool 
# 86 "../py/parse.h"
    mp_parse_node_is_const_true(mp_parse_node_t pn);

# 87 "../py/parse.h" 3 4
_Bool 
# 87 "../py/parse.h"
    mp_parse_node_get_int_maybe(mp_parse_node_t pn, mp_obj_t *o);
int mp_parse_node_extract_list(mp_parse_node_t *pn, size_t pn_kind, mp_parse_node_t **nodes);
void mp_parse_node_print(mp_parse_node_t pn, size_t indent);

typedef enum {
    MP_PARSE_SINGLE_INPUT,
    MP_PARSE_FILE_INPUT,
    MP_PARSE_EVAL_INPUT,
} mp_parse_input_kind_t;

typedef struct _mp_parse_t {
    mp_parse_node_t root;
    struct _mp_parse_chunk_t *chunk;
} mp_parse_tree_t;



mp_parse_tree_t mp_parse(struct _mp_lexer_t *lex, mp_parse_input_kind_t input_kind);
void mp_parse_tree_clear(mp_parse_tree_t *tree);
# 30 "../py/scope.h" 2
# 1 "../py/emitglue.h" 1
# 30 "../py/emitglue.h"
# 1 "../py/bc.h" 1
# 30 "../py/bc.h"
# 1 "../py/runtime.h" 1
# 29 "../py/runtime.h"
# 1 "../py/mpstate.h" 1
# 32 "../py/mpstate.h"
# 1 "../py/mpthread.h" 1
# 33 "../py/mpstate.h" 2

# 1 "../py/nlr.h" 1
# 32 "../py/nlr.h"
# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/arm-none-eabi/12.1.0/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/arm-none-eabi/12.1.0/include-fixed/limits.h" 1 3 4
# 203 "/usr/lib/gcc/arm-none-eabi/12.1.0/include-fixed/limits.h" 3 4
# 1 "/usr/arm-none-eabi/include/limits.h" 1 3 4





# 1 "/usr/arm-none-eabi/include/sys/syslimits.h" 1 3 4
# 7 "/usr/arm-none-eabi/include/limits.h" 2 3 4
# 204 "/usr/lib/gcc/arm-none-eabi/12.1.0/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/arm-none-eabi/12.1.0/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/arm-none-eabi/12.1.0/include-fixed/limits.h" 2 3 4
# 33 "../py/nlr.h" 2
# 1 "/usr/arm-none-eabi/include/assert.h" 1 3
# 39 "/usr/arm-none-eabi/include/assert.h" 3

# 39 "/usr/arm-none-eabi/include/assert.h" 3
void __assert (const char *, int, const char *)
     __attribute__ ((__noreturn__));
void __assert_func (const char *, int, const char *, const char *)
     __attribute__ ((__noreturn__));
# 34 "../py/nlr.h" 2
# 90 "../py/nlr.h"

# 90 "../py/nlr.h"
typedef struct _nlr_buf_t nlr_buf_t;
struct _nlr_buf_t {

    nlr_buf_t *prev;
    void *ret_val;




    void *regs[((10 + 6))];





};
# 133 "../py/nlr.h"
unsigned int nlr_push(nlr_buf_t *);


unsigned int nlr_push_tail(nlr_buf_t *top);
void nlr_pop(void);
__attribute__((noreturn)) void nlr_jump(void *val);




__attribute__((noreturn)) void nlr_jump_fail(void *val);
# 35 "../py/mpstate.h" 2

# 1 "../py/objlist.h" 1
# 31 "../py/objlist.h"
typedef struct _mp_obj_list_t {
    mp_obj_base_t base;
    size_t alloc;
    size_t len;
    mp_obj_t *items;
} mp_obj_list_t;

void mp_obj_list_init(mp_obj_list_t *o, size_t n);
# 37 "../py/mpstate.h" 2
# 1 "../py/objexcept.h" 1
# 30 "../py/objexcept.h"
# 1 "../py/objtuple.h" 1
# 31 "../py/objtuple.h"
typedef struct _mp_obj_tuple_t {
    mp_obj_base_t base;
    size_t len;
    mp_obj_t items[];
} mp_obj_tuple_t;

typedef struct _mp_rom_obj_tuple_t {
    mp_obj_base_t base;
    size_t len;
    mp_rom_obj_t items[];
} mp_rom_obj_tuple_t;

void mp_obj_tuple_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind);
mp_obj_t mp_obj_tuple_unary_op(mp_unary_op_t op, mp_obj_t self_in);
mp_obj_t mp_obj_tuple_binary_op(mp_binary_op_t op, mp_obj_t lhs, mp_obj_t rhs);
mp_obj_t mp_obj_tuple_subscr(mp_obj_t base, mp_obj_t index, mp_obj_t value);
mp_obj_t mp_obj_tuple_getiter(mp_obj_t o_in, mp_obj_iter_buf_t *iter_buf);

extern const mp_obj_type_t mp_type_attrtuple;
# 59 "../py/objtuple.h"
void mp_obj_attrtuple_print_helper(const mp_print_t *print, const qstr *fields, mp_obj_tuple_t *o);


mp_obj_t mp_obj_new_attrtuple(const qstr *fields, size_t n, const mp_obj_t *items);
# 31 "../py/objexcept.h" 2

typedef struct _mp_obj_exception_t {
    mp_obj_base_t base;
    size_t traceback_alloc : (8 * sizeof(size_t) / 2);
    size_t traceback_len : (8 * sizeof(size_t) / 2);
    size_t *traceback_data;
    mp_obj_tuple_t *args;
} mp_obj_exception_t;

void mp_obj_exception_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind);
void mp_obj_exception_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest);
# 38 "../py/mpstate.h" 2
# 60 "../py/mpstate.h"
typedef struct _mp_sched_item_t {
    mp_obj_t func;
    mp_obj_t arg;
} mp_sched_item_t;


typedef struct _mp_state_mem_t {






    byte *gc_alloc_table_start;
    size_t gc_alloc_table_byte_len;

    byte *gc_finaliser_table_start;

    byte *gc_pool_start;
    byte *gc_pool_end;

    int gc_stack_overflow;
    size_t gc_stack[(64)];
    uint16_t gc_lock_depth;




    uint16_t gc_auto_collect_enabled;


    size_t gc_alloc_amount;
    size_t gc_alloc_threshold;


    size_t gc_last_free_atb_index;


    size_t gc_collected;






} mp_state_mem_t;



typedef struct _mp_state_vm_t {







    qstr_pool_t *last_pool;


    mp_obj_exception_t mp_emergency_exception_obj;





    mp_obj_t mp_emergency_exception_buf[(128) / sizeof(mp_obj_t)];
# 135 "../py/mpstate.h"
    mp_obj_exception_t mp_kbd_exception;



    mp_obj_dict_t mp_loaded_modules_dict;


    volatile mp_obj_t mp_pending_exception;







    mp_obj_base_t *cur_exception;




    mp_obj_t sys_exitfunc;



    mp_obj_dict_t dict_main;


    mp_obj_list_t mp_sys_path_obj;
    mp_obj_list_t mp_sys_argv_obj;



    mp_obj_dict_t *mp_module_builtins_override_dict;



   
# 202 "../py/mpstate.h"
    byte *qstr_last_chunk;
    size_t qstr_last_alloc;
    size_t qstr_last_used;







    mp_uint_t mp_optimise_value;

    uint8_t default_emit_opt;
# 233 "../py/mpstate.h"
} mp_state_vm_t;



typedef struct _mp_state_thread_t {

    char *stack_top;


    size_t stack_limit;
# 257 "../py/mpstate.h"
    mp_obj_dict_t *dict_locals;
    mp_obj_dict_t *dict_globals;

    nlr_buf_t *nlr_top;






} mp_state_thread_t;



typedef struct _mp_state_ctx_t {
    mp_state_thread_t thread;
    mp_state_vm_t vm;
    mp_state_mem_t mem;
} mp_state_ctx_t;

extern mp_state_ctx_t mp_state_ctx;
# 30 "../py/runtime.h" 2
# 1 "../py/pystack.h" 1
# 80 "../py/pystack.h"
static inline void mp_local_free(void *ptr) {
    (void)ptr;
}

static inline void *mp_nonlocal_alloc(size_t n_bytes) {
    return ((uint8_t*)(m_malloc(sizeof(uint8_t) * (n_bytes))));
}

static inline void *mp_nonlocal_realloc(void *ptr, size_t old_n_bytes, size_t new_n_bytes) {
    return ((uint8_t*)(m_realloc((ptr), sizeof(uint8_t) * (old_n_bytes), sizeof(uint8_t) * (new_n_bytes))));
}

static inline void mp_nonlocal_free(void *ptr, size_t n_bytes) {
    m_free(ptr, sizeof(uint8_t) * (n_bytes));
}
# 31 "../py/runtime.h" 2

typedef enum {
    MP_VM_RETURN_NORMAL,
    MP_VM_RETURN_YIELD,
    MP_VM_RETURN_EXCEPTION,
} mp_vm_return_kind_t;

typedef enum {
    MP_ARG_BOOL = 0x001,
    MP_ARG_INT = 0x002,
    MP_ARG_OBJ = 0x003,
    MP_ARG_KIND_MASK = 0x0ff,
    MP_ARG_REQUIRED = 0x100,
    MP_ARG_KW_ONLY = 0x200,
} mp_arg_flag_t;

typedef union _mp_arg_val_t {
    
# 48 "../py/runtime.h" 3 4
   _Bool 
# 48 "../py/runtime.h"
        u_bool;
    mp_int_t u_int;
    mp_obj_t u_obj;
    mp_rom_obj_t u_rom_obj;
} mp_arg_val_t;

typedef struct _mp_arg_t {
    uint16_t qst;
    uint16_t flags;
    mp_arg_val_t defval;
} mp_arg_t;


extern const byte mp_unary_op_method_name[];
extern const byte mp_binary_op_method_name[];

void mp_init(void);
void mp_deinit(void);

void mp_handle_pending(void);
void mp_handle_pending_tail(mp_uint_t atomic_state);
# 78 "../py/runtime.h"
int mp_print_mp_int(const mp_print_t *print, mp_obj_t x, int base, int base_char, int flags, char fill, int width, int prec);

void mp_arg_check_num_sig(size_t n_args, size_t n_kw, uint32_t sig);
static inline void mp_arg_check_num(size_t n_args, size_t n_kw, size_t n_args_min, size_t n_args_max, 
# 81 "../py/runtime.h" 3 4
                                                                                                     _Bool 
# 81 "../py/runtime.h"
                                                                                                          takes_kw) {
    mp_arg_check_num_sig(n_args, n_kw, ((uint32_t)((((uint32_t)(n_args_min)) << 17) | (((uint32_t)(n_args_max)) << 1) | ((takes_kw) ? 1 : 0))));
}
void mp_arg_parse_all(size_t n_pos, const mp_obj_t *pos, mp_map_t *kws, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals);
void mp_arg_parse_all_kw_array(size_t n_pos, size_t n_kw, const mp_obj_t *args, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals);
__attribute__((noreturn)) void mp_arg_error_terse_mismatch(void);
__attribute__((noreturn)) void mp_arg_error_unimpl_kw(void);

static inline mp_obj_dict_t *mp_locals_get(void) { return (mp_state_ctx.thread.dict_locals); }
static inline void mp_locals_set(mp_obj_dict_t *d) { (mp_state_ctx.thread.dict_locals) = d; }
static inline mp_obj_dict_t *mp_globals_get(void) { return (mp_state_ctx.thread.dict_globals); }
static inline void mp_globals_set(mp_obj_dict_t *d) { (mp_state_ctx.thread.dict_globals) = d; }

mp_obj_t mp_load_name(qstr qst);
mp_obj_t mp_load_global(qstr qst);
mp_obj_t mp_load_build_class(void);
void mp_store_name(qstr qst, mp_obj_t obj);
void mp_store_global(qstr qst, mp_obj_t obj);
void mp_delete_name(qstr qst);
void mp_delete_global(qstr qst);

mp_obj_t mp_unary_op(mp_unary_op_t op, mp_obj_t arg);
mp_obj_t mp_binary_op(mp_binary_op_t op, mp_obj_t lhs, mp_obj_t rhs);

mp_obj_t mp_call_function_0(mp_obj_t fun);
mp_obj_t mp_call_function_1(mp_obj_t fun, mp_obj_t arg);
mp_obj_t mp_call_function_2(mp_obj_t fun, mp_obj_t arg1, mp_obj_t arg2);
mp_obj_t mp_call_function_n_kw(mp_obj_t fun, size_t n_args, size_t n_kw, const mp_obj_t *args);
mp_obj_t mp_call_method_n_kw(size_t n_args, size_t n_kw, const mp_obj_t *args);
mp_obj_t mp_call_method_n_kw_var(
# 110 "../py/runtime.h" 3 4
                                _Bool 
# 110 "../py/runtime.h"
                                     have_self, size_t n_args_n_kw, const mp_obj_t *args);
mp_obj_t mp_call_method_self_n_kw(mp_obj_t meth, mp_obj_t self, size_t n_args, size_t n_kw, const mp_obj_t *args);


mp_obj_t mp_call_function_1_protected(mp_obj_t fun, mp_obj_t arg);
mp_obj_t mp_call_function_2_protected(mp_obj_t fun, mp_obj_t arg1, mp_obj_t arg2);

typedef struct _mp_call_args_t {
    mp_obj_t fun;
    size_t n_args, n_kw, n_alloc;
    mp_obj_t *args;
} mp_call_args_t;
# 131 "../py/runtime.h"
void mp_unpack_sequence(mp_obj_t seq, size_t num, mp_obj_t *items);
void mp_unpack_ex(mp_obj_t seq, size_t num, mp_obj_t *items);
mp_obj_t mp_store_map(mp_obj_t map, mp_obj_t key, mp_obj_t value);
mp_obj_t mp_load_attr(mp_obj_t base, qstr attr);
void mp_convert_member_lookup(mp_obj_t obj, const mp_obj_type_t *type, mp_obj_t member, mp_obj_t *dest);
void mp_load_method(mp_obj_t base, qstr attr, mp_obj_t *dest);
void mp_load_method_maybe(mp_obj_t base, qstr attr, mp_obj_t *dest);
void mp_load_method_protected(mp_obj_t obj, qstr attr, mp_obj_t *dest, 
# 138 "../py/runtime.h" 3 4
                                                                      _Bool 
# 138 "../py/runtime.h"
                                                                           catch_all_exc);
void mp_load_super_method(qstr attr, mp_obj_t *dest);
void mp_store_attr(mp_obj_t base, qstr attr, mp_obj_t val);

mp_obj_t mp_getiter(mp_obj_t o, mp_obj_iter_buf_t *iter_buf);
mp_obj_t mp_iternext_allow_raise(mp_obj_t o);
mp_obj_t mp_iternext(mp_obj_t o);
mp_vm_return_kind_t mp_resume(mp_obj_t self_in, mp_obj_t send_value, mp_obj_t throw_value, mp_obj_t *ret_val);

mp_obj_t mp_make_raise_obj(mp_obj_t o);

mp_obj_t mp_import_name(qstr name, mp_obj_t fromlist, mp_obj_t level);
mp_obj_t mp_import_from(mp_obj_t module, qstr name);
void mp_import_all(mp_obj_t module);

__attribute__((noreturn)) void mp_raise_msg(const mp_obj_type_t *exc_type, const char *msg);
__attribute__((noreturn)) void mp_raise_ValueError(const char *msg);
__attribute__((noreturn)) void mp_raise_TypeError(const char *msg);
__attribute__((noreturn)) void mp_raise_NotImplementedError(const char *msg);
__attribute__((noreturn)) void mp_raise_OSError(int errno_);
__attribute__((noreturn)) void mp_raise_recursion_depth(void);
# 171 "../py/runtime.h"
int mp_native_type_from_qstr(qstr qst);
mp_uint_t mp_native_from_obj(mp_obj_t obj, mp_uint_t type);
mp_obj_t mp_native_to_obj(mp_uint_t val, mp_uint_t type);






void mp_warning(const char *category, const char *msg, ...);
# 31 "../py/bc.h" 2
# 1 "../py/objfun.h" 1
# 31 "../py/objfun.h"
typedef struct _mp_obj_fun_bc_t {
    mp_obj_base_t base;
    mp_obj_dict_t *globals;
    const byte *bytecode;
    const mp_uint_t *const_table;
# 44 "../py/objfun.h"
    mp_obj_t extra_args[];
} mp_obj_fun_bc_t;

void mp_obj_fun_bc_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest);
mp_obj_t fun_bc_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args);
mp_obj_t fun_builtin_1_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args);
# 32 "../py/bc.h" 2
# 175 "../py/bc.h"
typedef struct _mp_bytecode_prelude_t {
    uint n_state;
    uint n_exc_stack;
    uint scope_flags;
    uint n_pos_args;
    uint n_kwonly_args;
    uint n_def_pos_args;
    qstr qstr_block_name;
    qstr qstr_source_file;
    const byte *line_info;
    const byte *opcodes;
} mp_bytecode_prelude_t;


typedef struct _mp_exc_stack_t {
    const byte *handler;


    mp_obj_t *val_sp;

    mp_obj_base_t *prev_exc;
} mp_exc_stack_t;

typedef struct _mp_code_state_t {




    mp_obj_fun_bc_t *fun_bc;
    const byte *ip;
    mp_obj_t *sp;
    uint16_t n_state;
    uint16_t exc_sp_idx;
    mp_obj_dict_t *old_globals;
# 217 "../py/bc.h"
    mp_obj_t state[0];


} mp_code_state_t;

mp_uint_t mp_decode_uint(const byte **ptr);
mp_uint_t mp_decode_uint_value(const byte *ptr);
const byte *mp_decode_uint_skip(const byte *ptr);

mp_vm_return_kind_t mp_execute_bytecode(mp_code_state_t *code_state, volatile mp_obj_t inject_exc);
mp_code_state_t *mp_obj_fun_bc_prepare_codestate(mp_obj_t func, size_t n_args, size_t n_kw, const mp_obj_t *args);
void mp_setup_code_state(mp_code_state_t *code_state, size_t n_args, size_t n_kw, const mp_obj_t *args);
void mp_bytecode_print(const void *descr, const byte *code, mp_uint_t len, const mp_uint_t *const_table);
void mp_bytecode_print2(const byte *code, size_t len, const mp_uint_t *const_table);
const byte *mp_bytecode_print_str(const byte *ip);
# 246 "../py/bc.h"
static inline size_t mp_bytecode_get_source_line(const byte *line_info, size_t bc_offset) {
    size_t source_line = 1;
    size_t c;
    while ((c = *line_info)) {
        size_t b, l;
        if ((c & 0x80) == 0) {

            b = c & 0x1f;
            l = c >> 5;
            line_info += 1;
        } else {

            b = c & 0xf;
            l = ((c << 4) & 0x700) | line_info[1];
            line_info += 2;
        }
        if (bc_offset >= b) {
            bc_offset -= b;
            source_line += l;
        } else {

            break;
        }
    }
    return source_line;
}
# 31 "../py/emitglue.h" 2




enum {
    MP_EMIT_OPT_NONE,
    MP_EMIT_OPT_BYTECODE,
    MP_EMIT_OPT_NATIVE_PYTHON,
    MP_EMIT_OPT_VIPER,
    MP_EMIT_OPT_ASM,
};

typedef enum {
    MP_CODE_UNUSED,
    MP_CODE_RESERVED,
    MP_CODE_BYTECODE,
    MP_CODE_NATIVE_PY,
    MP_CODE_NATIVE_VIPER,
    MP_CODE_NATIVE_ASM,
} mp_raw_code_kind_t;

typedef struct _mp_qstr_link_entry_t {
    uint16_t off;
    uint16_t qst;
} mp_qstr_link_entry_t;

typedef struct _mp_raw_code_t {
    mp_uint_t kind : 3;
    mp_uint_t scope_flags : 7;
    mp_uint_t n_pos_args : 11;
    const void *fun_data;
    const mp_uint_t *const_table;
# 82 "../py/emitglue.h"
    mp_uint_t type_sig;

} mp_raw_code_t;

mp_raw_code_t *mp_emit_glue_new_raw_code(void);

void mp_emit_glue_assign_bytecode(mp_raw_code_t *rc, const byte *code,

    size_t len,

    const mp_uint_t *const_table,



    mp_uint_t scope_flags);

void mp_emit_glue_assign_native(mp_raw_code_t *rc, mp_raw_code_kind_t kind, void *fun_data, mp_uint_t fun_len,
    const mp_uint_t *const_table,





    mp_uint_t n_pos_args, mp_uint_t scope_flags, mp_uint_t type_sig);

mp_obj_t mp_make_function_from_raw_code(const mp_raw_code_t *rc, mp_obj_t def_args, mp_obj_t def_kw_args);
mp_obj_t mp_make_closure_from_raw_code(const mp_raw_code_t *rc, mp_uint_t n_closed_over, const mp_obj_t *args);
# 31 "../py/scope.h" 2

enum {
    ID_INFO_KIND_UNDECIDED,
    ID_INFO_KIND_GLOBAL_IMPLICIT,
    ID_INFO_KIND_GLOBAL_EXPLICIT,
    ID_INFO_KIND_LOCAL,
    ID_INFO_KIND_CELL,
    ID_INFO_KIND_FREE,
};

enum {
    ID_FLAG_IS_PARAM = 0x01,
    ID_FLAG_IS_STAR_PARAM = 0x02,
    ID_FLAG_IS_DBL_STAR_PARAM = 0x04,
    ID_FLAG_VIPER_TYPE_POS = 4,
};

typedef struct _id_info_t {
    uint8_t kind;
    uint8_t flags;


    uint16_t local_num;
    qstr qst;
} id_info_t;




typedef enum {
    SCOPE_MODULE,
    SCOPE_CLASS,
    SCOPE_LAMBDA,
    SCOPE_LIST_COMP,
    SCOPE_DICT_COMP,
    SCOPE_SET_COMP,
    SCOPE_GEN_EXPR,
    SCOPE_FUNCTION,
} scope_kind_t;

typedef struct _scope_t {
    scope_kind_t kind;
    struct _scope_t *parent;
    struct _scope_t *next;
    mp_parse_node_t pn;
    mp_raw_code_t *raw_code;
    uint16_t source_file;
    uint16_t simple_name;
    uint16_t scope_flags;
    uint16_t emit_options;
    uint16_t num_pos_args;
    uint16_t num_kwonly_args;
    uint16_t num_def_pos_args;
    uint16_t num_locals;
    uint16_t stack_size;
    uint16_t exc_stack_size;
    uint16_t id_info_alloc;
    uint16_t id_info_len;
    id_info_t *id_info;
} scope_t;

scope_t *scope_new(scope_kind_t kind, mp_parse_node_t pn, qstr source_file, mp_uint_t emit_options);
void scope_free(scope_t *scope);
id_info_t *scope_find_or_add_id(scope_t *scope, qstr qstr, scope_kind_t kind);
id_info_t *scope_find(scope_t *scope, qstr qstr);
id_info_t *scope_find_global(scope_t *scope, qstr qstr);
void scope_check_to_close_over(scope_t *scope, id_info_t *id);
# 34 "../py/compile.c" 2
# 1 "../py/emit.h" 1
# 29 "../py/emit.h"
# 1 "../py/lexer.h" 1
# 33 "../py/lexer.h"
# 1 "../py/reader.h" 1
# 36 "../py/reader.h"
typedef struct _mp_reader_t {
    void *data;
    mp_uint_t (*readbyte)(void *data);
    void (*close)(void *data);
} mp_reader_t;

void mp_reader_new_mem(mp_reader_t *reader, const byte *buf, size_t len, size_t free_len);
void mp_reader_new_file(mp_reader_t *reader, const char *filename);
void mp_reader_new_file_from_fd(mp_reader_t *reader, int fd, 
# 44 "../py/reader.h" 3 4
                                                            _Bool 
# 44 "../py/reader.h"
                                                                 close_fd);
# 34 "../py/lexer.h" 2







typedef enum _mp_token_kind_t {
    MP_TOKEN_END,

    MP_TOKEN_INVALID,
    MP_TOKEN_DEDENT_MISMATCH,
    MP_TOKEN_LONELY_STRING_OPEN,

    MP_TOKEN_NEWLINE,
    MP_TOKEN_INDENT,
    MP_TOKEN_DEDENT,

    MP_TOKEN_NAME,
    MP_TOKEN_INTEGER,
    MP_TOKEN_FLOAT_OR_IMAG,
    MP_TOKEN_STRING,
    MP_TOKEN_BYTES,

    MP_TOKEN_ELLIPSIS,

    MP_TOKEN_KW_FALSE,
    MP_TOKEN_KW_NONE,
    MP_TOKEN_KW_TRUE,
    MP_TOKEN_KW___DEBUG__,
    MP_TOKEN_KW_AND,
    MP_TOKEN_KW_AS,
    MP_TOKEN_KW_ASSERT,

    MP_TOKEN_KW_ASYNC,
    MP_TOKEN_KW_AWAIT,

    MP_TOKEN_KW_BREAK,
    MP_TOKEN_KW_CLASS,
    MP_TOKEN_KW_CONTINUE,
    MP_TOKEN_KW_DEF,
    MP_TOKEN_KW_DEL,
    MP_TOKEN_KW_ELIF,
    MP_TOKEN_KW_ELSE,
    MP_TOKEN_KW_EXCEPT,
    MP_TOKEN_KW_FINALLY,
    MP_TOKEN_KW_FOR,
    MP_TOKEN_KW_FROM,
    MP_TOKEN_KW_GLOBAL,
    MP_TOKEN_KW_IF,
    MP_TOKEN_KW_IMPORT,
    MP_TOKEN_KW_IN,
    MP_TOKEN_KW_IS,
    MP_TOKEN_KW_LAMBDA,
    MP_TOKEN_KW_NONLOCAL,
    MP_TOKEN_KW_NOT,
    MP_TOKEN_KW_OR,
    MP_TOKEN_KW_PASS,
    MP_TOKEN_KW_RAISE,
    MP_TOKEN_KW_RETURN,
    MP_TOKEN_KW_TRY,
    MP_TOKEN_KW_WHILE,
    MP_TOKEN_KW_WITH,
    MP_TOKEN_KW_YIELD,

    MP_TOKEN_OP_TILDE,


    MP_TOKEN_OP_LESS,
    MP_TOKEN_OP_MORE,
    MP_TOKEN_OP_DBL_EQUAL,
    MP_TOKEN_OP_LESS_EQUAL,
    MP_TOKEN_OP_MORE_EQUAL,
    MP_TOKEN_OP_NOT_EQUAL,


    MP_TOKEN_OP_PIPE,
    MP_TOKEN_OP_CARET,
    MP_TOKEN_OP_AMPERSAND,
    MP_TOKEN_OP_DBL_LESS,
    MP_TOKEN_OP_DBL_MORE,
    MP_TOKEN_OP_PLUS,
    MP_TOKEN_OP_MINUS,
    MP_TOKEN_OP_STAR,
    MP_TOKEN_OP_AT,
    MP_TOKEN_OP_DBL_SLASH,
    MP_TOKEN_OP_SLASH,
    MP_TOKEN_OP_PERCENT,
    MP_TOKEN_OP_DBL_STAR,


    MP_TOKEN_DEL_PIPE_EQUAL,
    MP_TOKEN_DEL_CARET_EQUAL,
    MP_TOKEN_DEL_AMPERSAND_EQUAL,
    MP_TOKEN_DEL_DBL_LESS_EQUAL,
    MP_TOKEN_DEL_DBL_MORE_EQUAL,
    MP_TOKEN_DEL_PLUS_EQUAL,
    MP_TOKEN_DEL_MINUS_EQUAL,
    MP_TOKEN_DEL_STAR_EQUAL,
    MP_TOKEN_DEL_AT_EQUAL,
    MP_TOKEN_DEL_DBL_SLASH_EQUAL,
    MP_TOKEN_DEL_SLASH_EQUAL,
    MP_TOKEN_DEL_PERCENT_EQUAL,
    MP_TOKEN_DEL_DBL_STAR_EQUAL,

    MP_TOKEN_DEL_PAREN_OPEN,
    MP_TOKEN_DEL_PAREN_CLOSE,
    MP_TOKEN_DEL_BRACKET_OPEN,
    MP_TOKEN_DEL_BRACKET_CLOSE,
    MP_TOKEN_DEL_BRACE_OPEN,
    MP_TOKEN_DEL_BRACE_CLOSE,
    MP_TOKEN_DEL_COMMA,
    MP_TOKEN_DEL_COLON,
    MP_TOKEN_DEL_PERIOD,
    MP_TOKEN_DEL_SEMICOLON,
    MP_TOKEN_DEL_EQUAL,
    MP_TOKEN_DEL_MINUS_MORE,
} mp_token_kind_t;



typedef struct _mp_lexer_t {
    qstr source_name;
    mp_reader_t reader;

    unichar chr0, chr1, chr2;

    size_t line;
    size_t column;

    mp_int_t emit_dent;
    mp_int_t nested_bracket_level;

    size_t alloc_indent_level;
    size_t num_indent_level;
    uint16_t *indent_level;

    size_t tok_line;
    size_t tok_column;
    mp_token_kind_t tok_kind;
    vstr_t vstr;
} mp_lexer_t;

mp_lexer_t *mp_lexer_new(qstr src_name, mp_reader_t reader);
mp_lexer_t *mp_lexer_new_from_str_len(qstr src_name, const char *str, size_t len, size_t free_len);

void mp_lexer_free(mp_lexer_t *lex);
void mp_lexer_to_next(mp_lexer_t *lex);





typedef enum {
    MP_IMPORT_STAT_NO_EXIST,
    MP_IMPORT_STAT_DIR,
    MP_IMPORT_STAT_FILE,
} mp_import_stat_t;

mp_import_stat_t mp_import_stat(const char *path);
mp_lexer_t *mp_lexer_new_from_file(const char *filename);


mp_lexer_t *mp_lexer_new_from_fd(qstr filename, int fd, 
# 197 "../py/lexer.h" 3 4
                                                       _Bool 
# 197 "../py/lexer.h"
                                                            close_fd);
# 30 "../py/emit.h" 2
# 42 "../py/emit.h"
typedef enum {
    MP_PASS_SCOPE = 1,
    MP_PASS_STACK_SIZE = 2,
    MP_PASS_CODE_SIZE = 3,
    MP_PASS_EMIT = 4,
} pass_kind_t;
# 93 "../py/emit.h"
typedef struct _emit_t emit_t;

typedef struct _mp_emit_method_table_id_ops_t {
    void (*local)(emit_t *emit, qstr qst, mp_uint_t local_num, int kind);
    void (*global)(emit_t *emit, qstr qst, int kind);
} mp_emit_method_table_id_ops_t;

typedef struct _emit_method_table_t {





    void (*start_pass)(emit_t *emit, pass_kind_t pass, scope_t *scope);
    void (*end_pass)(emit_t *emit);
    
# 108 "../py/emit.h" 3 4
   _Bool 
# 108 "../py/emit.h"
        (*last_emit_was_return_value)(emit_t *emit);
    void (*adjust_stack_size)(emit_t *emit, mp_int_t delta);
    void (*set_source_line)(emit_t *emit, mp_uint_t line);

    mp_emit_method_table_id_ops_t load_id;
    mp_emit_method_table_id_ops_t store_id;
    mp_emit_method_table_id_ops_t delete_id;

    void (*label_assign)(emit_t *emit, mp_uint_t l);
    void (*import)(emit_t *emit, qstr qst, int kind);
    void (*load_const_tok)(emit_t *emit, mp_token_kind_t tok);
    void (*load_const_small_int)(emit_t *emit, mp_int_t arg);
    void (*load_const_str)(emit_t *emit, qstr qst);
    void (*load_const_obj)(emit_t *emit, mp_obj_t obj);
    void (*load_null)(emit_t *emit);
    void (*load_method)(emit_t *emit, qstr qst, 
# 123 "../py/emit.h" 3 4
                                               _Bool 
# 123 "../py/emit.h"
                                                    is_super);
    void (*load_build_class)(emit_t *emit);
    void (*subscr)(emit_t *emit, int kind);
    void (*attr)(emit_t *emit, qstr qst, int kind);
    void (*dup_top)(emit_t *emit);
    void (*dup_top_two)(emit_t *emit);
    void (*pop_top)(emit_t *emit);
    void (*rot_two)(emit_t *emit);
    void (*rot_three)(emit_t *emit);
    void (*jump)(emit_t *emit, mp_uint_t label);
    void (*pop_jump_if)(emit_t *emit, 
# 133 "../py/emit.h" 3 4
                                     _Bool 
# 133 "../py/emit.h"
                                          cond, mp_uint_t label);
    void (*jump_if_or_pop)(emit_t *emit, 
# 134 "../py/emit.h" 3 4
                                        _Bool 
# 134 "../py/emit.h"
                                             cond, mp_uint_t label);
    void (*unwind_jump)(emit_t *emit, mp_uint_t label, mp_uint_t except_depth);
    void (*setup_block)(emit_t *emit, mp_uint_t label, int kind);
    void (*with_cleanup)(emit_t *emit, mp_uint_t label);
    void (*end_finally)(emit_t *emit);
    void (*get_iter)(emit_t *emit, 
# 139 "../py/emit.h" 3 4
                                  _Bool 
# 139 "../py/emit.h"
                                       use_stack);
    void (*for_iter)(emit_t *emit, mp_uint_t label);
    void (*for_iter_end)(emit_t *emit);
    void (*pop_except_jump)(emit_t *emit, mp_uint_t label, 
# 142 "../py/emit.h" 3 4
                                                          _Bool 
# 142 "../py/emit.h"
                                                               within_exc_handler);
    void (*unary_op)(emit_t *emit, mp_unary_op_t op);
    void (*binary_op)(emit_t *emit, mp_binary_op_t op);
    void (*build)(emit_t *emit, mp_uint_t n_args, int kind);
    void (*store_map)(emit_t *emit);
    void (*store_comp)(emit_t *emit, scope_kind_t kind, mp_uint_t set_stack_index);
    void (*unpack_sequence)(emit_t *emit, mp_uint_t n_args);
    void (*unpack_ex)(emit_t *emit, mp_uint_t n_left, mp_uint_t n_right);
    void (*make_function)(emit_t *emit, scope_t *scope, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults);
    void (*make_closure)(emit_t *emit, scope_t *scope, mp_uint_t n_closed_over, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults);
    void (*call_function)(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags);
    void (*call_method)(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags);
    void (*return_value)(emit_t *emit);
    void (*raise_varargs)(emit_t *emit, mp_uint_t n_args);
    void (*yield)(emit_t *emit, int kind);



    void (*start_except_handler)(emit_t *emit);
    void (*end_except_handler)(emit_t *emit);
} emit_method_table_t;

static inline void mp_emit_common_get_id_for_load(scope_t *scope, qstr qst) {
    scope_find_or_add_id(scope, qst, ID_INFO_KIND_GLOBAL_IMPLICIT);
}

void mp_emit_common_get_id_for_modification(scope_t *scope, qstr qst);
void mp_emit_common_id_op(emit_t *emit, const mp_emit_method_table_id_ops_t *emit_method_table, scope_t *scope, qstr qst);

extern const emit_method_table_t emit_bc_method_table;
extern const emit_method_table_t emit_native_x64_method_table;
extern const emit_method_table_t emit_native_x86_method_table;
extern const emit_method_table_t emit_native_thumb_method_table;
extern const emit_method_table_t emit_native_arm_method_table;
extern const emit_method_table_t emit_native_xtensa_method_table;
extern const emit_method_table_t emit_native_xtensawin_method_table;

extern const mp_emit_method_table_id_ops_t mp_emit_bc_method_table_load_id_ops;
extern const mp_emit_method_table_id_ops_t mp_emit_bc_method_table_store_id_ops;
extern const mp_emit_method_table_id_ops_t mp_emit_bc_method_table_delete_id_ops;

emit_t *emit_bc_new(void);
emit_t *emit_native_x64_new(mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);
emit_t *emit_native_x86_new(mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);
emit_t *emit_native_thumb_new(mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);
emit_t *emit_native_arm_new(mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);
emit_t *emit_native_xtensa_new(mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);
emit_t *emit_native_xtensawin_new(mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);

void emit_bc_set_max_num_labels(emit_t* emit, mp_uint_t max_num_labels);

void emit_bc_free(emit_t *emit);
void emit_native_x64_free(emit_t *emit);
void emit_native_x86_free(emit_t *emit);
void emit_native_thumb_free(emit_t *emit);
void emit_native_arm_free(emit_t *emit);
void emit_native_xtensa_free(emit_t *emit);
void emit_native_xtensawin_free(emit_t *emit);

void mp_emit_bc_start_pass(emit_t *emit, pass_kind_t pass, scope_t *scope);
void mp_emit_bc_end_pass(emit_t *emit);

# 203 "../py/emit.h" 3 4
_Bool 
# 203 "../py/emit.h"
    mp_emit_bc_last_emit_was_return_value(emit_t *emit);
void mp_emit_bc_adjust_stack_size(emit_t *emit, mp_int_t delta);
void mp_emit_bc_set_source_line(emit_t *emit, mp_uint_t line);

void mp_emit_bc_load_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind);
void mp_emit_bc_load_global(emit_t *emit, qstr qst, int kind);
void mp_emit_bc_store_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind);
void mp_emit_bc_store_global(emit_t *emit, qstr qst, int kind);
void mp_emit_bc_delete_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind);
void mp_emit_bc_delete_global(emit_t *emit, qstr qst, int kind);

void mp_emit_bc_label_assign(emit_t *emit, mp_uint_t l);
void mp_emit_bc_import(emit_t *emit, qstr qst, int kind);
void mp_emit_bc_load_const_tok(emit_t *emit, mp_token_kind_t tok);
void mp_emit_bc_load_const_small_int(emit_t *emit, mp_int_t arg);
void mp_emit_bc_load_const_str(emit_t *emit, qstr qst);
void mp_emit_bc_load_const_obj(emit_t *emit, mp_obj_t obj);
void mp_emit_bc_load_null(emit_t *emit);
void mp_emit_bc_load_method(emit_t *emit, qstr qst, 
# 221 "../py/emit.h" 3 4
                                                   _Bool 
# 221 "../py/emit.h"
                                                        is_super);
void mp_emit_bc_load_build_class(emit_t *emit);
void mp_emit_bc_subscr(emit_t *emit, int kind);
void mp_emit_bc_attr(emit_t *emit, qstr qst, int kind);
void mp_emit_bc_dup_top(emit_t *emit);
void mp_emit_bc_dup_top_two(emit_t *emit);
void mp_emit_bc_pop_top(emit_t *emit);
void mp_emit_bc_rot_two(emit_t *emit);
void mp_emit_bc_rot_three(emit_t *emit);
void mp_emit_bc_jump(emit_t *emit, mp_uint_t label);
void mp_emit_bc_pop_jump_if(emit_t *emit, 
# 231 "../py/emit.h" 3 4
                                         _Bool 
# 231 "../py/emit.h"
                                              cond, mp_uint_t label);
void mp_emit_bc_jump_if_or_pop(emit_t *emit, 
# 232 "../py/emit.h" 3 4
                                            _Bool 
# 232 "../py/emit.h"
                                                 cond, mp_uint_t label);
void mp_emit_bc_unwind_jump(emit_t *emit, mp_uint_t label, mp_uint_t except_depth);
void mp_emit_bc_setup_block(emit_t *emit, mp_uint_t label, int kind);
void mp_emit_bc_with_cleanup(emit_t *emit, mp_uint_t label);
void mp_emit_bc_end_finally(emit_t *emit);
void mp_emit_bc_get_iter(emit_t *emit, 
# 237 "../py/emit.h" 3 4
                                      _Bool 
# 237 "../py/emit.h"
                                           use_stack);
void mp_emit_bc_for_iter(emit_t *emit, mp_uint_t label);
void mp_emit_bc_for_iter_end(emit_t *emit);
void mp_emit_bc_pop_except_jump(emit_t *emit, mp_uint_t label, 
# 240 "../py/emit.h" 3 4
                                                              _Bool 
# 240 "../py/emit.h"
                                                                   within_exc_handler);
void mp_emit_bc_unary_op(emit_t *emit, mp_unary_op_t op);
void mp_emit_bc_binary_op(emit_t *emit, mp_binary_op_t op);
void mp_emit_bc_build(emit_t *emit, mp_uint_t n_args, int kind);
void mp_emit_bc_store_map(emit_t *emit);
void mp_emit_bc_store_comp(emit_t *emit, scope_kind_t kind, mp_uint_t list_stack_index);
void mp_emit_bc_unpack_sequence(emit_t *emit, mp_uint_t n_args);
void mp_emit_bc_unpack_ex(emit_t *emit, mp_uint_t n_left, mp_uint_t n_right);
void mp_emit_bc_make_function(emit_t *emit, scope_t *scope, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults);
void mp_emit_bc_make_closure(emit_t *emit, scope_t *scope, mp_uint_t n_closed_over, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults);
void mp_emit_bc_call_function(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags);
void mp_emit_bc_call_method(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags);
void mp_emit_bc_return_value(emit_t *emit);
void mp_emit_bc_raise_varargs(emit_t *emit, mp_uint_t n_args);
void mp_emit_bc_yield(emit_t *emit, int kind);
void mp_emit_bc_start_except_handler(emit_t *emit);
void mp_emit_bc_end_except_handler(emit_t *emit);

typedef struct _emit_inline_asm_t emit_inline_asm_t;

typedef struct _emit_inline_asm_method_table_t {





    void (*start_pass)(emit_inline_asm_t *emit, pass_kind_t pass, mp_obj_t *error_slot);
    void (*end_pass)(emit_inline_asm_t *emit, mp_uint_t type_sig);
    mp_uint_t (*count_params)(emit_inline_asm_t *emit, mp_uint_t n_params, mp_parse_node_t *pn_params);
    
# 269 "../py/emit.h" 3 4
   _Bool 
# 269 "../py/emit.h"
        (*label)(emit_inline_asm_t *emit, mp_uint_t label_num, qstr label_id);
    void (*op)(emit_inline_asm_t *emit, qstr op, mp_uint_t n_args, mp_parse_node_t *pn_args);
} emit_inline_asm_method_table_t;

extern const emit_inline_asm_method_table_t emit_inline_thumb_method_table;
extern const emit_inline_asm_method_table_t emit_inline_xtensa_method_table;

emit_inline_asm_t *emit_inline_thumb_new(mp_uint_t max_num_labels);
emit_inline_asm_t *emit_inline_xtensa_new(mp_uint_t max_num_labels);

void emit_inline_thumb_free(emit_inline_asm_t *emit);
void emit_inline_xtensa_free(emit_inline_asm_t *emit);


void mp_emitter_warning(pass_kind_t pass, const char *msg);
# 35 "../py/compile.c" 2
# 1 "../py/compile.h" 1
# 35 "../py/compile.h"
mp_obj_t mp_compile(mp_parse_tree_t *parse_tree, qstr source_file, 
# 35 "../py/compile.h" 3 4
                                                                  _Bool 
# 35 "../py/compile.h"
                                                                       is_repl);







mp_obj_t mp_parse_compile_execute(mp_lexer_t *lex, mp_parse_input_kind_t parse_input_kind, mp_obj_dict_t *globals, mp_obj_dict_t *locals);
# 36 "../py/compile.c" 2

# 1 "../py/asmbase.h" 1
# 35 "../py/asmbase.h"
typedef struct _mp_asm_base_t {
    int pass;
    size_t code_offset;
    size_t code_size;
    uint8_t *code_base;

    size_t max_num_labels;
    size_t *label_offsets;
} mp_asm_base_t;

void mp_asm_base_init(mp_asm_base_t *as, size_t max_num_labels);
void mp_asm_base_deinit(mp_asm_base_t *as, 
# 46 "../py/asmbase.h" 3 4
                                          _Bool 
# 46 "../py/asmbase.h"
                                               free_code);
void mp_asm_base_start_pass(mp_asm_base_t *as, int pass);
uint8_t *mp_asm_base_get_cur_to_write_bytes(mp_asm_base_t *as, size_t num_bytes_to_write);
void mp_asm_base_label_assign(mp_asm_base_t *as, size_t label);
void mp_asm_base_align(mp_asm_base_t* as, unsigned int align);
void mp_asm_base_data(mp_asm_base_t* as, unsigned int bytesize, uintptr_t val);

static inline size_t mp_asm_base_get_code_pos(mp_asm_base_t *as) {
    return as->code_offset;
}

static inline size_t mp_asm_base_get_code_size(mp_asm_base_t *as) {
    return as->code_size;
}

static inline void *mp_asm_base_get_code(mp_asm_base_t *as) {



    return as->code_base;

}
# 38 "../py/compile.c" 2
# 1 "../py/persistentcode.h" 1
# 92 "../py/persistentcode.h"
enum {
    MP_NATIVE_ARCH_NONE = 0,
    MP_NATIVE_ARCH_X86,
    MP_NATIVE_ARCH_X64,
    MP_NATIVE_ARCH_ARMV6,
    MP_NATIVE_ARCH_ARMV6M,
    MP_NATIVE_ARCH_ARMV7M,
    MP_NATIVE_ARCH_ARMV7EM,
    MP_NATIVE_ARCH_ARMV7EMSP,
    MP_NATIVE_ARCH_ARMV7EMDP,
    MP_NATIVE_ARCH_XTENSA,
    MP_NATIVE_ARCH_XTENSAWIN,
};

mp_raw_code_t *mp_raw_code_load(mp_reader_t *reader);
mp_raw_code_t *mp_raw_code_load_mem(const byte *buf, size_t len);
mp_raw_code_t *mp_raw_code_load_file(const char *filename);

void mp_raw_code_save(mp_raw_code_t *rc, mp_print_t *print);
void mp_raw_code_save_file(mp_raw_code_t *rc, const char *filename);

void mp_native_relocate(void *reloc, uint8_t *text, uintptr_t reloc_text);
# 39 "../py/compile.c" 2







typedef enum {



# 1 "../py/grammar.h" 1
# 40 "../py/grammar.h"

PN_file_input,
PN_file_input_2,



# 58 "../py/grammar.h"


PN_decorated,






PN_funcdef,


























PN_simple_stmt_2,








PN_expr_stmt,





PN_testlist_star_expr,


# 122 "../py/grammar.h"
PN_del_stmt,
PN_pass_stmt,

PN_break_stmt,
PN_continue_stmt,
PN_return_stmt,
PN_yield_stmt,
PN_raise_stmt,


# 145 "../py/grammar.h"

PN_import_name,
PN_import_from,












PN_global_stmt,
PN_nonlocal_stmt,

PN_assert_stmt,

# 179 "../py/grammar.h"

PN_async_stmt,




PN_if_stmt,


PN_while_stmt,
PN_for_stmt,
PN_try_stmt,







PN_with_stmt,





PN_suite_block_stmts,







PN_test_if_expr,


PN_lambdef,
PN_lambdef_nocond,
# 234 "../py/grammar.h"
PN_or_test,
PN_and_test,

PN_not_test_2,
PN_comparison,




PN_star_expr,
PN_expr,
PN_xor_expr,
PN_and_expr,
PN_shift_expr,

PN_arith_expr,

PN_term,


PN_factor_2,

PN_power,


PN_atom_expr_await,



PN_atom_expr_normal,








PN_atom_paren,

PN_atom_bracket,
PN_atom_brace,






PN_trailer_paren,
PN_trailer_bracket,
PN_trailer_period,






PN_subscriptlist,

PN_subscript_2,
PN_subscript_3,




# 307 "../py/grammar.h"


PN_testlist,



PN_dictorsetmaker_item,










PN_classdef,









# 342 "../py/grammar.h"













PN_yield_expr,


# 51 "../py/compile.c" 2


    PN_const_object,



# 1 "../py/grammar.h" 1
# 40 "../py/grammar.h"
PN_single_input,


PN_file_input_3,
PN_eval_input,
PN_eval_input_2,
# 58 "../py/grammar.h"
PN_decorator,
PN_decorators,


PN_decorated_body,
PN_async_funcdef,




PN_funcdefrettype,

PN_typedargslist,
PN_typedargslist_item,
PN_typedargslist_name,
PN_typedargslist_star,
PN_typedargslist_dbl_star,
PN_typedargslist_colon,
PN_typedargslist_equal,
PN_tfpdef,

PN_varargslist,
PN_varargslist_item,
PN_varargslist_name,
PN_varargslist_star,
PN_varargslist_dbl_star,
PN_varargslist_equal,
PN_vfpdef,



PN_stmt,



PN_simple_stmt,








PN_small_stmt,

PN_expr_stmt_2,
PN_expr_stmt_augassign,
PN_expr_stmt_assign_list,
PN_expr_stmt_assign,
PN_expr_stmt_6,

PN_testlist_star_expr_2,
PN_augassign,
# 122 "../py/grammar.h"


PN_flow_stmt,





PN_raise_stmt_arg,
PN_raise_stmt_from,
# 145 "../py/grammar.h"
PN_import_stmt,


PN_import_from_2,
PN_import_from_2b,
PN_import_from_3,
PN_import_as_names_paren,
PN_one_or_more_period_or_ellipsis,
PN_period_or_ellipsis,
PN_import_as_name,
PN_dotted_as_name,
PN_as_name,
PN_import_as_names,
PN_dotted_as_names,
PN_dotted_name,


PN_name_list,

PN_assert_stmt_extra,
# 179 "../py/grammar.h"
PN_compound_stmt,

PN_async_stmt_2,




PN_if_stmt_elif_list,
PN_if_stmt_elif,



PN_try_stmt_2,
PN_try_stmt_except_and_more,
PN_try_stmt_except,
PN_try_stmt_as_name,
PN_try_stmt_except_list,
PN_try_stmt_finally,
PN_else_stmt,

PN_with_stmt_list,
PN_with_item,
PN_with_item_as,
PN_suite,
PN_suite_block,







PN_test,

PN_test_if_else,
PN_test_nocond,


# 234 "../py/grammar.h"


PN_not_test,


PN_comp_op,
PN_comp_op_not_in,
PN_comp_op_is,
PN_comp_op_is_not,





PN_shift_op,

PN_arith_op,

PN_term_op,
PN_factor,

PN_factor_op,


PN_atom_expr,





PN_atom_expr_trailers,
PN_power_dbl_star,





PN_atom,

PN_atom_2b,


PN_testlist_comp,
PN_testlist_comp_2,
PN_testlist_comp_3,
PN_testlist_comp_3b,
PN_testlist_comp_3c,
PN_trailer,










PN_subscript,


PN_subscript_3b,
PN_subscript_3c,
PN_subscript_3d,
PN_sliceop,
# 307 "../py/grammar.h"
PN_exprlist,
PN_exprlist_2,


PN_dictorsetmaker,


PN_dictorsetmaker_colon,



PN_dictorsetmaker_tail,
PN_dictorsetmaker_list,
PN_dictorsetmaker_list2,




PN_classdef_2,




PN_arglist,
PN_arglist_2,
PN_arglist_star,
PN_arglist_dbl_star,
# 342 "../py/grammar.h"
PN_argument,
PN_argument_2,
PN_argument_3,
PN_comp_iter,
PN_comp_for,
PN_comp_if,








PN_yield_arg,
PN_yield_arg_from,
# 58 "../py/compile.c" 2


} pn_kind_t;
# 158 "../py/compile.c"
typedef struct _compiler_t {
    qstr source_file;

    uint8_t is_repl;
    uint8_t pass;
    uint8_t have_star;


    mp_obj_t compile_error;
    size_t compile_error_line;

    uint next_label;

    uint16_t num_dict_params;
    uint16_t num_default_params;

    uint16_t break_label;
    uint16_t continue_label;
    uint16_t cur_except_level;
    uint16_t break_continue_except_level;

    scope_t *scope_head;
    scope_t *scope_cur;

    emit_t *emit;

    const emit_method_table_t *emit_method_table;






} compiler_t;

static void compile_error_set_line(compiler_t *comp, mp_parse_node_t pn) {

    if (comp->compile_error_line == 0 && ((pn) != (0) && ((pn) & 3) == 0)) {
        comp->compile_error_line = ((mp_parse_node_struct_t*)pn)->source_line;
    }
}

static void compile_syntax_error(compiler_t *comp, mp_parse_node_t pn, const char *msg) {

    if (comp->compile_error == (((mp_obj_t)(void*)0))) {
        comp->compile_error = mp_obj_new_exception_msg(&mp_type_SyntaxError, msg);
        compile_error_set_line(comp, pn);
    }
}

static void compile_trailer_paren_helper(compiler_t *comp, mp_parse_node_t pn_arglist, 
# 208 "../py/compile.c" 3 4
                                                                                      _Bool 
# 208 "../py/compile.c"
                                                                                           is_method_call, int n_positional_extra);
static void compile_comprehension(compiler_t *comp, mp_parse_node_struct_t *pns, scope_kind_t kind);
static void compile_atom_brace_helper(compiler_t *comp, mp_parse_node_struct_t *pns, 
# 210 "../py/compile.c" 3 4
                                                                                    _Bool 
# 210 "../py/compile.c"
                                                                                         create_map);
static void compile_node(compiler_t *comp, mp_parse_node_t pn);

static uint comp_next_label(compiler_t *comp) {
    return comp->next_label++;
}


static void reserve_labels_for_native(compiler_t *comp, int n) {
    if (comp->scope_cur->emit_options != MP_EMIT_OPT_BYTECODE) {
        comp->next_label += n;
    }
}




static void compile_increase_except_level(compiler_t *comp, uint label, int kind) {
    (comp->emit_method_table->setup_block(comp->emit, label, kind));
    comp->cur_except_level += 1;
    if (comp->cur_except_level > comp->scope_cur->exc_stack_size) {
        comp->scope_cur->exc_stack_size = comp->cur_except_level;
    }
}

static void compile_decrease_except_level(compiler_t *comp) {
    
# 236 "../py/compile.c" 3
   ((
# 236 "../py/compile.c"
   comp->cur_except_level > 0
# 236 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 236, __func__, 
# 236 "../py/compile.c"
   "comp->cur_except_level > 0"
# 236 "../py/compile.c" 3
   ))
# 236 "../py/compile.c"
                                     ;
    comp->cur_except_level -= 1;
    (comp->emit_method_table->end_finally(comp->emit));
    reserve_labels_for_native(comp, 1);
}

static scope_t *scope_new_and_link(compiler_t *comp, scope_kind_t kind, mp_parse_node_t pn, uint emit_options) {
    scope_t *scope = scope_new(kind, pn, comp->source_file, emit_options);
    scope->parent = comp->scope_cur;
    scope->next = 
# 245 "../py/compile.c" 3 4
                 ((void *)0)
# 245 "../py/compile.c"
                     ;
    if (comp->scope_head == 
# 246 "../py/compile.c" 3 4
                           ((void *)0)
# 246 "../py/compile.c"
                               ) {
        comp->scope_head = scope;
    } else {
        scope_t *s = comp->scope_head;
        while (s->next != 
# 250 "../py/compile.c" 3 4
                         ((void *)0)
# 250 "../py/compile.c"
                             ) {
            s = s->next;
        }
        s->next = scope;
    }
    return scope;
}

typedef void (*apply_list_fun_t)(compiler_t *comp, mp_parse_node_t pn);

static void apply_to_single_or_list(compiler_t *comp, mp_parse_node_t pn, pn_kind_t pn_list_kind, apply_list_fun_t f) {
    if (((pn) != (0) && ((pn) & 3) == 0 && (((mp_parse_node_struct_t*)(pn))->kind_num_nodes & 0xff) == (pn_list_kind))) {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        int num_nodes = ((pns)->kind_num_nodes >> 8);
        for (int i = 0; i < num_nodes; i++) {
            f(comp, pns->nodes[i]);
        }
    } else if (!((pn) == (0))) {
        f(comp, pn);
    }
}

static void compile_generic_all_nodes(compiler_t *comp, mp_parse_node_struct_t *pns) {
    int num_nodes = ((pns)->kind_num_nodes >> 8);
    for (int i = 0; i < num_nodes; i++) {
        compile_node(comp, pns->nodes[i]);
        if (comp->compile_error != (((mp_obj_t)(void*)0))) {

            compile_error_set_line(comp, pns->nodes[i]);
            return;
        }
    }
}

static void compile_load_id(compiler_t *comp, qstr qst) {
    if (comp->pass == MP_PASS_SCOPE) {
        mp_emit_common_get_id_for_load(comp->scope_cur, qst);
    } else {

        mp_emit_common_id_op(comp->emit, &comp->emit_method_table->load_id, comp->scope_cur, qst);



    }
}

static void compile_store_id(compiler_t *comp, qstr qst) {
    if (comp->pass == MP_PASS_SCOPE) {
        mp_emit_common_get_id_for_modification(comp->scope_cur, qst);
    } else {

        mp_emit_common_id_op(comp->emit, &comp->emit_method_table->store_id, comp->scope_cur, qst);



    }
}

static void compile_delete_id(compiler_t *comp, qstr qst) {
    if (comp->pass == MP_PASS_SCOPE) {
        mp_emit_common_get_id_for_modification(comp->scope_cur, qst);
    } else {

        mp_emit_common_id_op(comp->emit, &comp->emit_method_table->delete_id, comp->scope_cur, qst);



    }
}

static void c_tuple(compiler_t *comp, mp_parse_node_t pn, mp_parse_node_struct_t *pns_list) {
    int total = 0;
    if (!((pn) == (0))) {
        compile_node(comp, pn);
        total += 1;
    }
    if (pns_list != 
# 326 "../py/compile.c" 3 4
                   ((void *)0)
# 326 "../py/compile.c"
                       ) {
        int n = ((pns_list)->kind_num_nodes >> 8);
        for (int i = 0; i < n; i++) {
            compile_node(comp, pns_list->nodes[i]);
        }
        total += n;
    }
    (comp->emit_method_table->build(comp->emit, total, (0)));
}

static void compile_generic_tuple(compiler_t *comp, mp_parse_node_struct_t *pns) {

    c_tuple(comp, (0), pns);
}

static void c_if_cond(compiler_t *comp, mp_parse_node_t pn, 
# 341 "../py/compile.c" 3 4
                                                           _Bool 
# 341 "../py/compile.c"
                                                                jump_if, int label) {
    if (mp_parse_node_is_const_false(pn)) {
        if (jump_if == 
# 343 "../py/compile.c" 3 4
                      0
# 343 "../py/compile.c"
                           ) {
            (comp->emit_method_table->jump(comp->emit, label));
        }
        return;
    } else if (mp_parse_node_is_const_true(pn)) {
        if (jump_if == 
# 348 "../py/compile.c" 3 4
                      1
# 348 "../py/compile.c"
                          ) {
            (comp->emit_method_table->jump(comp->emit, label));
        }
        return;
    } else if (((pn) != (0) && ((pn) & 3) == 0)) {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        int n = ((pns)->kind_num_nodes >> 8);
        if (((pns)->kind_num_nodes & 0xff) == PN_or_test) {
            if (jump_if == 
# 356 "../py/compile.c" 3 4
                          0
# 356 "../py/compile.c"
                               ) {
            and_or_logic1:;
                uint label2 = comp_next_label(comp);
                for (int i = 0; i < n - 1; i++) {
                    c_if_cond(comp, pns->nodes[i], !jump_if, label2);
                }
                c_if_cond(comp, pns->nodes[n - 1], jump_if, label);
                (comp->emit_method_table->label_assign(comp->emit, label2));
            } else {
            and_or_logic2:
                for (int i = 0; i < n; i++) {
                    c_if_cond(comp, pns->nodes[i], jump_if, label);
                }
            }
            return;
        } else if (((pns)->kind_num_nodes & 0xff) == PN_and_test) {
            if (jump_if == 
# 372 "../py/compile.c" 3 4
                          0
# 372 "../py/compile.c"
                               ) {
                goto and_or_logic2;
            } else {
                goto and_or_logic1;
            }
        } else if (((pns)->kind_num_nodes & 0xff) == PN_not_test_2) {
            c_if_cond(comp, pns->nodes[0], !jump_if, label);
            return;
        } else if (((pns)->kind_num_nodes & 0xff) == PN_atom_paren) {

            if (((pns->nodes[0]) == (0))) {

                if (jump_if == 
# 384 "../py/compile.c" 3 4
                              0
# 384 "../py/compile.c"
                                   ) {
                    (comp->emit_method_table->jump(comp->emit, label));
                }
            } else {
                
# 388 "../py/compile.c" 3
               ((
# 388 "../py/compile.c"
               ((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_testlist_comp))
# 388 "../py/compile.c" 3
               ) ? (void)0 : __assert_func ("../py/compile.c", 388, __func__, 
# 388 "../py/compile.c"
               "MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp)"
# 388 "../py/compile.c" 3
               ))
# 388 "../py/compile.c"
                                                                                    ;

                if (jump_if == 
# 390 "../py/compile.c" 3 4
                              1
# 390 "../py/compile.c"
                                  ) {
                    (comp->emit_method_table->jump(comp->emit, label));
                }
            }
            return;
        }
    }


    compile_node(comp, pn);
    (comp->emit_method_table->pop_jump_if(comp->emit, jump_if, label));
}

typedef enum { ASSIGN_STORE, ASSIGN_AUG_LOAD, ASSIGN_AUG_STORE } assign_kind_t;
static void c_assign(compiler_t *comp, mp_parse_node_t pn, assign_kind_t kind);

static void c_assign_atom_expr(compiler_t *comp, mp_parse_node_struct_t *pns, assign_kind_t assign_kind) {
    if (assign_kind != ASSIGN_AUG_STORE) {
        compile_node(comp, pns->nodes[0]);
    }

    if (((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0)) {
        mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t*)pns->nodes[1];
        if (((pns1)->kind_num_nodes & 0xff) == PN_atom_expr_trailers) {
            int n = ((pns1)->kind_num_nodes >> 8);
            if (assign_kind != ASSIGN_AUG_STORE) {
                for (int i = 0; i < n - 1; i++) {
                    compile_node(comp, pns1->nodes[i]);
                }
            }
            
# 420 "../py/compile.c" 3
           ((
# 420 "../py/compile.c"
           ((pns1->nodes[n - 1]) != (0) && ((pns1->nodes[n - 1]) & 3) == 0)
# 420 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 420, __func__, 
# 420 "../py/compile.c"
           "MP_PARSE_NODE_IS_STRUCT(pns1->nodes[n - 1])"
# 420 "../py/compile.c" 3
           ))
# 420 "../py/compile.c"
                                                              ;
            pns1 = (mp_parse_node_struct_t*)pns1->nodes[n - 1];
        }
        if (((pns1)->kind_num_nodes & 0xff) == PN_trailer_bracket) {
            if (assign_kind == ASSIGN_AUG_STORE) {
                (comp->emit_method_table->rot_three(comp->emit));
                (comp->emit_method_table->subscr(comp->emit, (1)));
            } else {
                compile_node(comp, pns1->nodes[0]);
                if (assign_kind == ASSIGN_AUG_LOAD) {
                    (comp->emit_method_table->dup_top_two(comp->emit));
                    (comp->emit_method_table->subscr(comp->emit, (0)));
                } else {
                    (comp->emit_method_table->subscr(comp->emit, (1)));
                }
            }
            return;
        } else if (((pns1)->kind_num_nodes & 0xff) == PN_trailer_period) {
            
# 438 "../py/compile.c" 3
           ((
# 438 "../py/compile.c"
           (((pns1->nodes[0]) & 0x0f) == (0x02))
# 438 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 438, __func__, 
# 438 "../py/compile.c"
           "MP_PARSE_NODE_IS_ID(pns1->nodes[0])"
# 438 "../py/compile.c" 3
           ))
# 438 "../py/compile.c"
                                                      ;
            if (assign_kind == ASSIGN_AUG_LOAD) {
                (comp->emit_method_table->dup_top(comp->emit));
                (comp->emit_method_table->attr(comp->emit, (((uintptr_t)(pns1->nodes[0])) >> 4), (0)));
            } else {
                if (assign_kind == ASSIGN_AUG_STORE) {
                    (comp->emit_method_table->rot_two(comp->emit));
                }
                (comp->emit_method_table->attr(comp->emit, (((uintptr_t)(pns1->nodes[0])) >> 4), (1)));
            }
            return;
        }
    }

    compile_syntax_error(comp, (mp_parse_node_t)pns, "can't assign to expression");
}


static void c_assign_tuple(compiler_t *comp, mp_parse_node_t node_head, uint num_tail, mp_parse_node_t *nodes_tail) {
    uint num_head = (node_head == (0)) ? 0 : 1;


    uint have_star_index = -1;
    if (num_head != 0 && ((node_head) != (0) && ((node_head) & 3) == 0 && (((mp_parse_node_struct_t*)(node_head))->kind_num_nodes & 0xff) == (PN_star_expr))) {
        (comp->emit_method_table->unpack_ex(comp->emit, 0, num_tail));
        have_star_index = 0;
    }
    for (uint i = 0; i < num_tail; i++) {
        if (((nodes_tail[i]) != (0) && ((nodes_tail[i]) & 3) == 0 && (((mp_parse_node_struct_t*)(nodes_tail[i]))->kind_num_nodes & 0xff) == (PN_star_expr))) {
            if (have_star_index == (uint)-1) {
                (comp->emit_method_table->unpack_ex(comp->emit, num_head + i, num_tail - i - 1));
                have_star_index = num_head + i;
            } else {
                compile_syntax_error(comp, nodes_tail[i], "multiple *x in assignment");
                return;
            }
        }
    }
    if (have_star_index == (uint)-1) {
        (comp->emit_method_table->unpack_sequence(comp->emit, num_head + num_tail));
    }
    if (num_head != 0) {
        if (0 == have_star_index) {
            c_assign(comp, ((mp_parse_node_struct_t*)node_head)->nodes[0], ASSIGN_STORE);
        } else {
            c_assign(comp, node_head, ASSIGN_STORE);
        }
    }
    for (uint i = 0; i < num_tail; i++) {
        if (num_head + i == have_star_index) {
            c_assign(comp, ((mp_parse_node_struct_t*)nodes_tail[i])->nodes[0], ASSIGN_STORE);
        } else {
            c_assign(comp, nodes_tail[i], ASSIGN_STORE);
        }
    }
}


static void c_assign(compiler_t *comp, mp_parse_node_t pn, assign_kind_t assign_kind) {
    
# 497 "../py/compile.c" 3
   ((
# 497 "../py/compile.c"
   !((pn) == (0))
# 497 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 497, __func__, 
# 497 "../py/compile.c"
   "!MP_PARSE_NODE_IS_NULL(pn)"
# 497 "../py/compile.c" 3
   ))
# 497 "../py/compile.c"
                                     ;
    if (((pn) & 3)) {
        if ((((pn) & 0x0f) == (0x02))) {
            qstr arg = (((uintptr_t)(pn)) >> 4);
            switch (assign_kind) {
                case ASSIGN_STORE:
                case ASSIGN_AUG_STORE:
                    compile_store_id(comp, arg);
                    break;
                case ASSIGN_AUG_LOAD:
                default:
                    compile_load_id(comp, arg);
                    break;
            }
        } else {
            goto cannot_assign;
        }
    } else {

        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        switch (((pns)->kind_num_nodes & 0xff)) {
            case PN_atom_expr_normal:

                c_assign_atom_expr(comp, pns, assign_kind);
                break;

            case PN_testlist_star_expr:
            case PN_exprlist:

                if (assign_kind != ASSIGN_STORE) {
                    goto cannot_assign;
                }
                c_assign_tuple(comp, (0), ((pns)->kind_num_nodes >> 8), pns->nodes);
                break;

            case PN_atom_paren:

                if (((pns->nodes[0]) == (0))) {

                    goto cannot_assign;
                } else {
                    
# 538 "../py/compile.c" 3
                   ((
# 538 "../py/compile.c"
                   ((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_testlist_comp))
# 538 "../py/compile.c" 3
                   ) ? (void)0 : __assert_func ("../py/compile.c", 538, __func__, 
# 538 "../py/compile.c"
                   "MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp)"
# 538 "../py/compile.c" 3
                   ))
# 538 "../py/compile.c"
                                                                                        ;
                    if (assign_kind != ASSIGN_STORE) {
                        goto cannot_assign;
                    }
                    pns = (mp_parse_node_struct_t*)pns->nodes[0];
                    goto testlist_comp;
                }
                break;

            case PN_atom_bracket:

                if (assign_kind != ASSIGN_STORE) {
                    goto cannot_assign;
                }
                if (((pns->nodes[0]) == (0))) {

                    c_assign_tuple(comp, (0), 0, 
# 554 "../py/compile.c" 3 4
                                                               ((void *)0)
# 554 "../py/compile.c"
                                                                   );
                } else if (((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_testlist_comp))) {
                    pns = (mp_parse_node_struct_t*)pns->nodes[0];
                    goto testlist_comp;
                } else {

                    c_assign_tuple(comp, pns->nodes[0], 0, 
# 560 "../py/compile.c" 3 4
                                                          ((void *)0)
# 560 "../py/compile.c"
                                                              );
                }
                break;

            default:
                goto cannot_assign;
        }
        return;

        testlist_comp:

        if (((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0)) {
            mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t*)pns->nodes[1];
            if (((pns2)->kind_num_nodes & 0xff) == PN_testlist_comp_3b) {

                
# 575 "../py/compile.c" 3
               ((
# 575 "../py/compile.c"
               ((pns2->nodes[0]) == (0))
# 575 "../py/compile.c" 3
               ) ? (void)0 : __assert_func ("../py/compile.c", 575, __func__, 
# 575 "../py/compile.c"
               "MP_PARSE_NODE_IS_NULL(pns2->nodes[0])"
# 575 "../py/compile.c" 3
               ))
# 575 "../py/compile.c"
                                                            ;
                c_assign_tuple(comp, pns->nodes[0], 0, 
# 576 "../py/compile.c" 3 4
                                                      ((void *)0)
# 576 "../py/compile.c"
                                                          );
            } else if (((pns2)->kind_num_nodes & 0xff) == PN_testlist_comp_3c) {

                uint n = ((pns2)->kind_num_nodes >> 8);
                c_assign_tuple(comp, pns->nodes[0], n, pns2->nodes);
            } else if (((pns2)->kind_num_nodes & 0xff) == PN_comp_for) {
                goto cannot_assign;
            } else {

                goto sequence_with_2_items;
            }
        } else {

            sequence_with_2_items:
            c_assign_tuple(comp, (0), 2, pns->nodes);
        }
        return;
    }
    return;

    cannot_assign:
    compile_syntax_error(comp, pn, "can't assign to expression");
}





static void close_over_variables_etc(compiler_t *comp, scope_t *this_scope, int n_pos_defaults, int n_kw_defaults) {
    
# 605 "../py/compile.c" 3
   ((
# 605 "../py/compile.c"
   n_pos_defaults >= 0
# 605 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 605, __func__, 
# 605 "../py/compile.c"
   "n_pos_defaults >= 0"
# 605 "../py/compile.c" 3
   ))
# 605 "../py/compile.c"
                              ;
    
# 606 "../py/compile.c" 3
   ((
# 606 "../py/compile.c"
   n_kw_defaults >= 0
# 606 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 606, __func__, 
# 606 "../py/compile.c"
   "n_kw_defaults >= 0"
# 606 "../py/compile.c" 3
   ))
# 606 "../py/compile.c"
                             ;


    if (n_kw_defaults > 0) {
        this_scope->scope_flags |= (0x08);
    }
    this_scope->num_def_pos_args = n_pos_defaults;



    comp->scope_cur->scope_flags |= (0x10) | (0x20);




    int nfree = 0;
    if (comp->scope_cur->kind != SCOPE_MODULE) {
        for (int i = 0; i < comp->scope_cur->id_info_len; i++) {
            id_info_t *id = &comp->scope_cur->id_info[i];
            if (id->kind == ID_INFO_KIND_CELL || id->kind == ID_INFO_KIND_FREE) {
                for (int j = 0; j < this_scope->id_info_len; j++) {
                    id_info_t *id2 = &this_scope->id_info[j];
                    if (id2->kind == ID_INFO_KIND_FREE && id->qst == id2->qst) {

                        (comp->emit_method_table->load_id.local(comp->emit, id->qst, id->local_num, (0)));
                        nfree += 1;
                    }
                }
            }
        }
    }


    if (nfree == 0) {
        (comp->emit_method_table->make_function(comp->emit, this_scope, n_pos_defaults, n_kw_defaults));
    } else {
        (comp->emit_method_table->make_closure(comp->emit, this_scope, nfree, n_pos_defaults, n_kw_defaults));
    }
}

static void compile_funcdef_lambdef_param(compiler_t *comp, mp_parse_node_t pn) {

    int pn_kind;
    if ((((pn) & 0x0f) == (0x02))) {
        pn_kind = -1;
    } else {
        
# 652 "../py/compile.c" 3
       ((
# 652 "../py/compile.c"
       ((pn) != (0) && ((pn) & 3) == 0)
# 652 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 652, __func__, 
# 652 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT(pn)"
# 652 "../py/compile.c" 3
       ))
# 652 "../py/compile.c"
                                          ;
        pn_kind = (((mp_parse_node_struct_t*)pn)->kind_num_nodes & 0xff);
    }

    if (pn_kind == PN_typedargslist_star || pn_kind == PN_varargslist_star) {
        comp->have_star = 
# 657 "../py/compile.c" 3 4
                         1
# 657 "../py/compile.c"
                             ;
# 667 "../py/compile.c"
    } else if (pn_kind == PN_typedargslist_dbl_star || pn_kind == PN_varargslist_dbl_star) {



    } else {
        mp_parse_node_t pn_id;
        mp_parse_node_t pn_equal;
        if (pn_kind == -1) {


            pn_id = pn;
            pn_equal = (0);

        } else if (pn_kind == PN_typedargslist_name) {


            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
            pn_id = pns->nodes[0];

            pn_equal = pns->nodes[2];

        } else {
            
# 689 "../py/compile.c" 3
           ((
# 689 "../py/compile.c"
           pn_kind == PN_varargslist_name
# 689 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 689, __func__, 
# 689 "../py/compile.c"
           "pn_kind == PN_varargslist_name"
# 689 "../py/compile.c" 3
           ))
# 689 "../py/compile.c"
                                                 ;


            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
            pn_id = pns->nodes[0];
            pn_equal = pns->nodes[1];
        }

        if (((pn_equal) == (0))) {



            if (!comp->have_star && comp->num_default_params != 0) {
                compile_syntax_error(comp, pn, "non-default argument follows default argument");
                return;
            }

        } else {



            if (comp->have_star) {
                comp->num_dict_params += 1;

                if (comp->num_dict_params == 1) {


                    if (comp->num_default_params > 0) {
                        (comp->emit_method_table->build(comp->emit, comp->num_default_params, (0)));
                    } else {
                        (comp->emit_method_table->load_null(comp->emit));
                    }

                    (comp->emit_method_table->build(comp->emit, 0, (2)));
                }


                compile_node(comp, pn_equal);
                (comp->emit_method_table->load_const_str(comp->emit, (((uintptr_t)(pn_id)) >> 4)));
                (comp->emit_method_table->store_map(comp->emit));
            } else {
                comp->num_default_params += 1;
                compile_node(comp, pn_equal);
            }
        }
    }
}

static void compile_funcdef_lambdef(compiler_t *comp, scope_t *scope, mp_parse_node_t pn_params, pn_kind_t pn_list_kind) {



    
# 741 "../py/compile.c" 3 4
   _Bool 
# 741 "../py/compile.c"
        orig_have_star = comp->have_star;
    uint16_t orig_num_dict_params = comp->num_dict_params;
    uint16_t orig_num_default_params = comp->num_default_params;


    comp->have_star = 
# 746 "../py/compile.c" 3 4
                     0
# 746 "../py/compile.c"
                          ;
    comp->num_dict_params = 0;
    comp->num_default_params = 0;
    apply_to_single_or_list(comp, pn_params, pn_list_kind, compile_funcdef_lambdef_param);

    if (comp->compile_error != (((mp_obj_t)(void*)0))) {
        return;
    }



    if (comp->num_default_params > 0 && comp->num_dict_params == 0) {
        (comp->emit_method_table->build(comp->emit, comp->num_default_params, (0)));
        (comp->emit_method_table->load_null(comp->emit));
    }


    close_over_variables_etc(comp, scope, comp->num_default_params, comp->num_dict_params);


    comp->have_star = orig_have_star;
    comp->num_dict_params = orig_num_dict_params;
    comp->num_default_params = orig_num_default_params;
}



static qstr compile_funcdef_helper(compiler_t *comp, mp_parse_node_struct_t *pns, uint emit_options) {
    if (comp->pass == MP_PASS_SCOPE) {

        scope_t *s = scope_new_and_link(comp, SCOPE_FUNCTION, (mp_parse_node_t)pns, emit_options);

        pns->nodes[4] = (mp_parse_node_t)s;
    }


    scope_t *fscope = (scope_t*)pns->nodes[4];


    compile_funcdef_lambdef(comp, fscope, pns->nodes[1], PN_typedargslist);


    return fscope->simple_name;
}



static qstr compile_classdef_helper(compiler_t *comp, mp_parse_node_struct_t *pns, uint emit_options) {
    if (comp->pass == MP_PASS_SCOPE) {

        scope_t *s = scope_new_and_link(comp, SCOPE_CLASS, (mp_parse_node_t)pns, emit_options);

        pns->nodes[3] = (mp_parse_node_t)s;
    }

    (comp->emit_method_table->load_build_class(comp->emit));


    scope_t *cscope = (scope_t*)pns->nodes[3];


    close_over_variables_etc(comp, cscope, 0, 0);


    (comp->emit_method_table->load_const_str(comp->emit, cscope->simple_name));



    mp_parse_node_t parents = pns->nodes[1];
    if (((parents) != (0) && ((parents) & 3) == 0 && (((mp_parse_node_struct_t*)(parents))->kind_num_nodes & 0xff) == (PN_classdef_2))) {
        parents = (0);
    }
    compile_trailer_paren_helper(comp, parents, 
# 818 "../py/compile.c" 3 4
                                               0
# 818 "../py/compile.c"
                                                    , 2);


    return cscope->simple_name;
}


static 
# 825 "../py/compile.c" 3 4
      _Bool 
# 825 "../py/compile.c"
           compile_built_in_decorator(compiler_t *comp, int name_len, mp_parse_node_t *name_nodes, uint *emit_options) {
    if ((((uintptr_t)(name_nodes[0])) >> 4) != MP_QSTR_micropython) {
        return 
# 827 "../py/compile.c" 3 4
              0
# 827 "../py/compile.c"
                   ;
    }

    if (name_len != 2) {
        compile_syntax_error(comp, name_nodes[0], "invalid micropython decorator");
        return 
# 832 "../py/compile.c" 3 4
              1
# 832 "../py/compile.c"
                  ;
    }

    qstr attr = (((uintptr_t)(name_nodes[1])) >> 4);
    if (attr == MP_QSTR_bytecode) {
        *emit_options = MP_EMIT_OPT_BYTECODE;

    } else if (attr == MP_QSTR_native) {
        *emit_options = MP_EMIT_OPT_NATIVE_PYTHON;
    } else if (attr == MP_QSTR_viper) {
        *emit_options = MP_EMIT_OPT_VIPER;
# 855 "../py/compile.c"
    } else {
        compile_syntax_error(comp, name_nodes[1], "invalid micropython decorator");
    }
# 871 "../py/compile.c"
    return 
# 871 "../py/compile.c" 3 4
          1
# 871 "../py/compile.c"
              ;
}

static void compile_decorated(compiler_t *comp, mp_parse_node_struct_t *pns) {

    mp_parse_node_t *nodes;
    int n = mp_parse_node_extract_list(&pns->nodes[0], PN_decorators, &nodes);


    uint emit_options = comp->scope_cur->emit_options;


    int num_built_in_decorators = 0;
    for (int i = 0; i < n; i++) {
        
# 885 "../py/compile.c" 3
       ((
# 885 "../py/compile.c"
       ((nodes[i]) != (0) && ((nodes[i]) & 3) == 0 && (((mp_parse_node_struct_t*)(nodes[i]))->kind_num_nodes & 0xff) == (PN_decorator))
# 885 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 885, __func__, 
# 885 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT_KIND(nodes[i], PN_decorator)"
# 885 "../py/compile.c" 3
       ))
# 885 "../py/compile.c"
                                                                   ;
        mp_parse_node_struct_t *pns_decorator = (mp_parse_node_struct_t*)nodes[i];


        mp_parse_node_t *name_nodes;
        int name_len = mp_parse_node_extract_list(&pns_decorator->nodes[0], PN_dotted_name, &name_nodes);


        if (compile_built_in_decorator(comp, name_len, name_nodes, &emit_options)) {

            num_built_in_decorators += 1;

        } else {



            compile_node(comp, name_nodes[0]);
            for (int j = 1; j < name_len; j++) {
                
# 903 "../py/compile.c" 3
               ((
# 903 "../py/compile.c"
               (((name_nodes[j]) & 0x0f) == (0x02))
# 903 "../py/compile.c" 3
               ) ? (void)0 : __assert_func ("../py/compile.c", 903, __func__, 
# 903 "../py/compile.c"
               "MP_PARSE_NODE_IS_ID(name_nodes[j])"
# 903 "../py/compile.c" 3
               ))
# 903 "../py/compile.c"
                                                         ;
                (comp->emit_method_table->attr(comp->emit, (((uintptr_t)(name_nodes[j])) >> 4), (0)));
            }


            if (!((pns_decorator->nodes[1]) == (0))) {

                compile_node(comp, pns_decorator->nodes[1]);
            }
        }
    }


    mp_parse_node_struct_t *pns_body = (mp_parse_node_struct_t*)pns->nodes[1];
    qstr body_name = 0;
    if (((pns_body)->kind_num_nodes & 0xff) == PN_funcdef) {
        body_name = compile_funcdef_helper(comp, pns_body, emit_options);

    } else if (((pns_body)->kind_num_nodes & 0xff) == PN_async_funcdef) {
        
# 922 "../py/compile.c" 3
       ((
# 922 "../py/compile.c"
       ((pns_body->nodes[0]) != (0) && ((pns_body->nodes[0]) & 3) == 0)
# 922 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 922, __func__, 
# 922 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT(pns_body->nodes[0])"
# 922 "../py/compile.c" 3
       ))
# 922 "../py/compile.c"
                                                          ;
        mp_parse_node_struct_t *pns0 = (mp_parse_node_struct_t*)pns_body->nodes[0];
        body_name = compile_funcdef_helper(comp, pns0, emit_options);
        scope_t *fscope = (scope_t*)pns0->nodes[4];
        fscope->scope_flags |= (0x01);

    } else {
        
# 929 "../py/compile.c" 3
       ((
# 929 "../py/compile.c"
       ((pns_body)->kind_num_nodes & 0xff) == PN_classdef
# 929 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 929, __func__, 
# 929 "../py/compile.c"
       "MP_PARSE_NODE_STRUCT_KIND(pns_body) == PN_classdef"
# 929 "../py/compile.c" 3
       ))
# 929 "../py/compile.c"
                                                                 ;
        body_name = compile_classdef_helper(comp, pns_body, emit_options);
    }


    for (int i = 0; i < n - num_built_in_decorators; i++) {
        (comp->emit_method_table->call_function(comp->emit, 1, 0, 0));
    }


    compile_store_id(comp, body_name);
}

static void compile_funcdef(compiler_t *comp, mp_parse_node_struct_t *pns) {
    qstr fname = compile_funcdef_helper(comp, pns, comp->scope_cur->emit_options);

    compile_store_id(comp, fname);
}

static void c_del_stmt(compiler_t *comp, mp_parse_node_t pn) {
    if ((((pn) & 0x0f) == (0x02))) {
        compile_delete_id(comp, (((uintptr_t)(pn)) >> 4));
    } else if (((pn) != (0) && ((pn) & 3) == 0 && (((mp_parse_node_struct_t*)(pn))->kind_num_nodes & 0xff) == (PN_atom_expr_normal))) {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;

        compile_node(comp, pns->nodes[0]);

        if (((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0)) {
            mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t*)pns->nodes[1];
            if (((pns1)->kind_num_nodes & 0xff) == PN_atom_expr_trailers) {
                int n = ((pns1)->kind_num_nodes >> 8);
                for (int i = 0; i < n - 1; i++) {
                    compile_node(comp, pns1->nodes[i]);
                }
                
# 963 "../py/compile.c" 3
               ((
# 963 "../py/compile.c"
               ((pns1->nodes[n - 1]) != (0) && ((pns1->nodes[n - 1]) & 3) == 0)
# 963 "../py/compile.c" 3
               ) ? (void)0 : __assert_func ("../py/compile.c", 963, __func__, 
# 963 "../py/compile.c"
               "MP_PARSE_NODE_IS_STRUCT(pns1->nodes[n - 1])"
# 963 "../py/compile.c" 3
               ))
# 963 "../py/compile.c"
                                                                  ;
                pns1 = (mp_parse_node_struct_t*)pns1->nodes[n - 1];
            }
            if (((pns1)->kind_num_nodes & 0xff) == PN_trailer_bracket) {
                compile_node(comp, pns1->nodes[0]);
                (comp->emit_method_table->subscr(comp->emit, (2)));
            } else if (((pns1)->kind_num_nodes & 0xff) == PN_trailer_period) {
                
# 970 "../py/compile.c" 3
               ((
# 970 "../py/compile.c"
               (((pns1->nodes[0]) & 0x0f) == (0x02))
# 970 "../py/compile.c" 3
               ) ? (void)0 : __assert_func ("../py/compile.c", 970, __func__, 
# 970 "../py/compile.c"
               "MP_PARSE_NODE_IS_ID(pns1->nodes[0])"
# 970 "../py/compile.c" 3
               ))
# 970 "../py/compile.c"
                                                          ;
                (comp->emit_method_table->attr(comp->emit, (((uintptr_t)(pns1->nodes[0])) >> 4), (2)));
            } else {
                goto cannot_delete;
            }
        } else {
            goto cannot_delete;
        }

    } else if (((pn) != (0) && ((pn) & 3) == 0 && (((mp_parse_node_struct_t*)(pn))->kind_num_nodes & 0xff) == (PN_atom_paren))) {
        pn = ((mp_parse_node_struct_t*)pn)->nodes[0];
        if (((pn) == (0))) {
            goto cannot_delete;
        } else {
            
# 984 "../py/compile.c" 3
           ((
# 984 "../py/compile.c"
           ((pn) != (0) && ((pn) & 3) == 0 && (((mp_parse_node_struct_t*)(pn))->kind_num_nodes & 0xff) == (PN_testlist_comp))
# 984 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 984, __func__, 
# 984 "../py/compile.c"
           "MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_testlist_comp)"
# 984 "../py/compile.c" 3
           ))
# 984 "../py/compile.c"
                                                                     ;
            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;


            if (((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0)) {
                mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t*)pns->nodes[1];
                if (((pns1)->kind_num_nodes & 0xff) == PN_testlist_comp_3b) {

                    
# 992 "../py/compile.c" 3
                   ((
# 992 "../py/compile.c"
                   ((pns1->nodes[0]) == (0))
# 992 "../py/compile.c" 3
                   ) ? (void)0 : __assert_func ("../py/compile.c", 992, __func__, 
# 992 "../py/compile.c"
                   "MP_PARSE_NODE_IS_NULL(pns1->nodes[0])"
# 992 "../py/compile.c" 3
                   ))
# 992 "../py/compile.c"
                                                                ;
                    c_del_stmt(comp, pns->nodes[0]);
                } else if (((pns1)->kind_num_nodes & 0xff) == PN_testlist_comp_3c) {

                    int n = ((pns1)->kind_num_nodes >> 8);
                    c_del_stmt(comp, pns->nodes[0]);
                    for (int i = 0; i < n; i++) {
                        c_del_stmt(comp, pns1->nodes[i]);
                    }
                } else if (((pns1)->kind_num_nodes & 0xff) == PN_comp_for) {
                    goto cannot_delete;
                } else {

                    goto sequence_with_2_items;
                }
            } else {

                sequence_with_2_items:
                c_del_stmt(comp, pns->nodes[0]);
                c_del_stmt(comp, pns->nodes[1]);
            }
        }
    } else {

        goto cannot_delete;
    }

    return;

cannot_delete:
    compile_syntax_error(comp, (mp_parse_node_t)pn, "can't delete expression");
}

static void compile_del_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {
    apply_to_single_or_list(comp, pns->nodes[0], PN_exprlist, c_del_stmt);
}

static void compile_break_cont_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {
    uint16_t label;
    if (((pns)->kind_num_nodes & 0xff) == PN_break_stmt) {
        label = comp->break_label;
    } else {
        label = comp->continue_label;
    }
    if (label == (0xffff)) {
        compile_syntax_error(comp, (mp_parse_node_t)pns, "'break'/'continue' outside loop");
    }
    
# 1039 "../py/compile.c" 3
   ((
# 1039 "../py/compile.c"
   comp->cur_except_level >= comp->break_continue_except_level
# 1039 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 1039, __func__, 
# 1039 "../py/compile.c"
   "comp->cur_except_level >= comp->break_continue_except_level"
# 1039 "../py/compile.c" 3
   ))
# 1039 "../py/compile.c"
                                                                      ;
    (comp->emit_method_table->unwind_jump(comp->emit, label, comp->cur_except_level - comp->break_continue_except_level));
}

static void compile_return_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->scope_cur->kind != SCOPE_FUNCTION) {
        compile_syntax_error(comp, (mp_parse_node_t)pns, "'return' outside function");
        return;
    }
    if (((pns->nodes[0]) == (0))) {

        (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
    } else if ((1)
        && ((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_test_if_expr))) {

        mp_parse_node_struct_t *pns_test_if_expr = (mp_parse_node_struct_t*)pns->nodes[0];
        mp_parse_node_struct_t *pns_test_if_else = (mp_parse_node_struct_t*)pns_test_if_expr->nodes[1];

        uint l_fail = comp_next_label(comp);
        c_if_cond(comp, pns_test_if_else->nodes[0], 
# 1058 "../py/compile.c" 3 4
                                                   0
# 1058 "../py/compile.c"
                                                        , l_fail);
        compile_node(comp, pns_test_if_expr->nodes[0]);
        (comp->emit_method_table->return_value(comp->emit));
        (comp->emit_method_table->label_assign(comp->emit, l_fail));
        compile_node(comp, pns_test_if_else->nodes[1]);
    } else {
        compile_node(comp, pns->nodes[0]);
    }
    (comp->emit_method_table->return_value(comp->emit));
}

static void compile_yield_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {
    compile_node(comp, pns->nodes[0]);
    (comp->emit_method_table->pop_top(comp->emit));
}

static void compile_raise_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (((pns->nodes[0]) == (0))) {

        (comp->emit_method_table->raise_varargs(comp->emit, 0));
    } else if (((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_raise_stmt_arg))) {

        pns = (mp_parse_node_struct_t*)pns->nodes[0];
        compile_node(comp, pns->nodes[0]);
        compile_node(comp, pns->nodes[1]);
        (comp->emit_method_table->raise_varargs(comp->emit, 2));
    } else {

        compile_node(comp, pns->nodes[0]);
        (comp->emit_method_table->raise_varargs(comp->emit, 1));
    }
}




static void do_import_name(compiler_t *comp, mp_parse_node_t pn, qstr *q_base) {
    
# 1095 "../py/compile.c" 3 4
   _Bool 
# 1095 "../py/compile.c"
        is_as = 
# 1095 "../py/compile.c" 3 4
                0
# 1095 "../py/compile.c"
                     ;
    if (((pn) != (0) && ((pn) & 3) == 0 && (((mp_parse_node_struct_t*)(pn))->kind_num_nodes & 0xff) == (PN_dotted_as_name))) {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;

        *q_base = (((uintptr_t)(pns->nodes[1])) >> 4);
        pn = pns->nodes[0];
        is_as = 
# 1101 "../py/compile.c" 3 4
               1
# 1101 "../py/compile.c"
                   ;
    }
    if (((pn) == (0))) {

        *q_base = MP_QSTR_;
        (comp->emit_method_table->import(comp->emit, MP_QSTR_, (0)));
    } else if ((((pn) & 0x0f) == (0x02))) {

        qstr q_full = (((uintptr_t)(pn)) >> 4);
        if (!is_as) {
            *q_base = q_full;
        }
        (comp->emit_method_table->import(comp->emit, q_full, (0)));
    } else {
        
# 1115 "../py/compile.c" 3
       ((
# 1115 "../py/compile.c"
       ((pn) != (0) && ((pn) & 3) == 0 && (((mp_parse_node_struct_t*)(pn))->kind_num_nodes & 0xff) == (PN_dotted_name))
# 1115 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 1115, __func__, 
# 1115 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_dotted_name)"
# 1115 "../py/compile.c" 3
       ))
# 1115 "../py/compile.c"
                                                               ;
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        {

            if (!is_as) {
                *q_base = (((uintptr_t)(pns->nodes[0])) >> 4);
            }
            int n = ((pns)->kind_num_nodes >> 8);
            int len = n - 1;
            for (int i = 0; i < n; i++) {
                len += qstr_len((((uintptr_t)(pns->nodes[i])) >> 4));
            }
            char *q_ptr = 
# 1127 "../py/compile.c" 3
                         __builtin_alloca(
# 1127 "../py/compile.c"
                         len
# 1127 "../py/compile.c" 3
                         )
# 1127 "../py/compile.c"
                                            ;
            char *str_dest = q_ptr;
            for (int i = 0; i < n; i++) {
                if (i > 0) {
                    *str_dest++ = '.';
                }
                size_t str_src_len;
                const byte *str_src = qstr_data((((uintptr_t)(pns->nodes[i])) >> 4), &str_src_len);
                memcpy(str_dest, str_src, str_src_len);
                str_dest += str_src_len;
            }
            if (q_ptr == 
# 1138 "../py/compile.c" 3 4
                        ((void *)0)
# 1138 "../py/compile.c"
                            ) {
                compile_syntax_error(comp, pn, "out of memory");
                return;
            }

            qstr q_full = qstr_from_strn(q_ptr, len);
            mp_local_free(q_ptr);
            (comp->emit_method_table->import(comp->emit, q_full, (0)));
            if (is_as) {
                for (int i = 1; i < n; i++) {
                    (comp->emit_method_table->attr(comp->emit, (((uintptr_t)(pns->nodes[i])) >> 4), (0)));
                }
            }
        }
    }
}

static void compile_dotted_as_name(compiler_t *comp, mp_parse_node_t pn) {
    (comp->emit_method_table->load_const_small_int(comp->emit, 0));
    (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
    qstr q_base;
    do_import_name(comp, pn, &q_base);
    compile_store_id(comp, q_base);
}

static void compile_import_name(compiler_t *comp, mp_parse_node_struct_t *pns) {
    apply_to_single_or_list(comp, pns->nodes[0], PN_dotted_as_names, compile_dotted_as_name);
}

static void compile_import_from(compiler_t *comp, mp_parse_node_struct_t *pns) {
    mp_parse_node_t pn_import_source = pns->nodes[0];


    uint import_level = 0;
    do {
        mp_parse_node_t pn_rel;
        if ((((pn_import_source) & 0x0f) == (0x0e)) || ((pn_import_source) != (0) && ((pn_import_source) & 3) == 0 && (((mp_parse_node_struct_t*)(pn_import_source))->kind_num_nodes & 0xff) == (PN_one_or_more_period_or_ellipsis))) {

            pn_rel = pn_import_source;
            pn_import_source = (0);
        } else if (((pn_import_source) != (0) && ((pn_import_source) & 3) == 0 && (((mp_parse_node_struct_t*)(pn_import_source))->kind_num_nodes & 0xff) == (PN_import_from_2b))) {

            mp_parse_node_struct_t *pns_2b = (mp_parse_node_struct_t*)pn_import_source;
            pn_rel = pns_2b->nodes[0];
            pn_import_source = pns_2b->nodes[1];
            
# 1183 "../py/compile.c" 3
           ((
# 1183 "../py/compile.c"
           !((pn_import_source) == (0))
# 1183 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 1183, __func__, 
# 1183 "../py/compile.c"
           "!MP_PARSE_NODE_IS_NULL(pn_import_source)"
# 1183 "../py/compile.c" 3
           ))
# 1183 "../py/compile.c"
                                                           ;
        } else {

            break;
        }


        mp_parse_node_t *nodes;
        int n = mp_parse_node_extract_list(&pn_rel, PN_one_or_more_period_or_ellipsis, &nodes);


        for (int i = 0; i < n; i++) {
            if (((nodes[i]) == ((0x0e) | ((MP_TOKEN_DEL_PERIOD) << 4)))) {
                import_level++;
            } else {

                import_level += 3;
            }
        }
    } while (0);

    if (((pns->nodes[1]) == ((0x0e) | ((MP_TOKEN_OP_STAR) << 4)))) {

        if (comp->scope_cur->kind != SCOPE_MODULE) {
            compile_syntax_error(comp, (mp_parse_node_t)pns, "import * not at module level");
            return;
        }


        (comp->emit_method_table->load_const_small_int(comp->emit, import_level));


        (comp->emit_method_table->load_const_str(comp->emit, MP_QSTR__star_));
        (comp->emit_method_table->build(comp->emit, 1, (0)));


        qstr dummy_q;
        do_import_name(comp, pn_import_source, &dummy_q);
        (comp->emit_method_table->import(comp->emit, MP_QSTRnull, (2)));

    } else {
        (comp->emit_method_table->load_const_small_int(comp->emit, import_level));


        mp_parse_node_t *pn_nodes;
        int n = mp_parse_node_extract_list(&pns->nodes[1], PN_import_as_names, &pn_nodes);
        for (int i = 0; i < n; i++) {
            
# 1230 "../py/compile.c" 3
           ((
# 1230 "../py/compile.c"
           ((pn_nodes[i]) != (0) && ((pn_nodes[i]) & 3) == 0 && (((mp_parse_node_struct_t*)(pn_nodes[i]))->kind_num_nodes & 0xff) == (PN_import_as_name))
# 1230 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 1230, __func__, 
# 1230 "../py/compile.c"
           "MP_PARSE_NODE_IS_STRUCT_KIND(pn_nodes[i], PN_import_as_name)"
# 1230 "../py/compile.c" 3
           ))
# 1230 "../py/compile.c"
                                                                               ;
            mp_parse_node_struct_t *pns3 = (mp_parse_node_struct_t*)pn_nodes[i];
            qstr id2 = (((uintptr_t)(pns3->nodes[0])) >> 4);
            (comp->emit_method_table->load_const_str(comp->emit, id2));
        }
        (comp->emit_method_table->build(comp->emit, n, (0)));


        qstr dummy_q;
        do_import_name(comp, pn_import_source, &dummy_q);
        for (int i = 0; i < n; i++) {
            
# 1241 "../py/compile.c" 3
           ((
# 1241 "../py/compile.c"
           ((pn_nodes[i]) != (0) && ((pn_nodes[i]) & 3) == 0 && (((mp_parse_node_struct_t*)(pn_nodes[i]))->kind_num_nodes & 0xff) == (PN_import_as_name))
# 1241 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 1241, __func__, 
# 1241 "../py/compile.c"
           "MP_PARSE_NODE_IS_STRUCT_KIND(pn_nodes[i], PN_import_as_name)"
# 1241 "../py/compile.c" 3
           ))
# 1241 "../py/compile.c"
                                                                               ;
            mp_parse_node_struct_t *pns3 = (mp_parse_node_struct_t*)pn_nodes[i];
            qstr id2 = (((uintptr_t)(pns3->nodes[0])) >> 4);
            (comp->emit_method_table->import(comp->emit, id2, (1)));
            if (((pns3->nodes[1]) == (0))) {
                compile_store_id(comp, id2);
            } else {
                compile_store_id(comp, (((uintptr_t)(pns3->nodes[1])) >> 4));
            }
        }
        (comp->emit_method_table->pop_top(comp->emit));
    }
}

static void compile_declare_global(compiler_t *comp, mp_parse_node_t pn, id_info_t *id_info) {
    if (id_info->kind != ID_INFO_KIND_UNDECIDED && id_info->kind != ID_INFO_KIND_GLOBAL_EXPLICIT) {
        compile_syntax_error(comp, pn, "identifier redefined as global");
        return;
    }
    id_info->kind = ID_INFO_KIND_GLOBAL_EXPLICIT;


    id_info = scope_find_global(comp->scope_cur, id_info->qst);
    if (id_info != 
# 1264 "../py/compile.c" 3 4
                  ((void *)0)
# 1264 "../py/compile.c"
                      ) {
        id_info->kind = ID_INFO_KIND_GLOBAL_EXPLICIT;
    }
}

static void compile_declare_nonlocal(compiler_t *comp, mp_parse_node_t pn, id_info_t *id_info) {
    if (id_info->kind == ID_INFO_KIND_UNDECIDED) {
        id_info->kind = ID_INFO_KIND_GLOBAL_IMPLICIT;
        scope_check_to_close_over(comp->scope_cur, id_info);
        if (id_info->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {
            compile_syntax_error(comp, pn, "no binding for nonlocal found");
        }
    } else if (id_info->kind != ID_INFO_KIND_FREE) {
        compile_syntax_error(comp, pn, "identifier redefined as nonlocal");
    }
}

static void compile_global_nonlocal_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->pass == MP_PASS_SCOPE) {
        
# 1283 "../py/compile.c" 3 4
       _Bool 
# 1283 "../py/compile.c"
            is_global = ((pns)->kind_num_nodes & 0xff) == PN_global_stmt;

        if (!is_global && comp->scope_cur->kind == SCOPE_MODULE) {
            compile_syntax_error(comp, (mp_parse_node_t)pns, "can't declare nonlocal in outer code");
            return;
        }

        mp_parse_node_t *nodes;
        int n = mp_parse_node_extract_list(&pns->nodes[0], PN_name_list, &nodes);
        for (int i = 0; i < n; i++) {
            qstr qst = (((uintptr_t)(nodes[i])) >> 4);
            id_info_t *id_info = scope_find_or_add_id(comp->scope_cur, qst, ID_INFO_KIND_UNDECIDED);
            if (is_global) {
                compile_declare_global(comp, (mp_parse_node_t)pns, id_info);
            } else {
                compile_declare_nonlocal(comp, (mp_parse_node_t)pns, id_info);
            }
        }
    }
}

static void compile_assert_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {

    if ((mp_state_ctx.vm.mp_optimise_value) != 0) {
        return;
    }

    uint l_end = comp_next_label(comp);
    c_if_cond(comp, pns->nodes[0], 
# 1311 "../py/compile.c" 3 4
                                  1
# 1311 "../py/compile.c"
                                      , l_end);
    (comp->emit_method_table->load_id.global(comp->emit, MP_QSTR_AssertionError, (1)));
    if (!((pns->nodes[1]) == (0))) {

        compile_node(comp, pns->nodes[1]);
        (comp->emit_method_table->call_function(comp->emit, 1, 0, 0));
    }
    (comp->emit_method_table->raise_varargs(comp->emit, 1));
    (comp->emit_method_table->label_assign(comp->emit, l_end));
}

static void compile_if_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {
    uint l_end = comp_next_label(comp);


    if (!mp_parse_node_is_const_false(pns->nodes[0])) {
        uint l_fail = comp_next_label(comp);
        c_if_cond(comp, pns->nodes[0], 
# 1328 "../py/compile.c" 3 4
                                      0
# 1328 "../py/compile.c"
                                           , l_fail);

        compile_node(comp, pns->nodes[1]);


        if (mp_parse_node_is_const_true(pns->nodes[0])) {
            goto done;
        }

        if (

            !(((pns->nodes[2]) == (0)) && ((pns->nodes[3]) == (0)))

            && !(comp->emit_method_table->last_emit_was_return_value(comp->emit))
            ) {

            (comp->emit_method_table->jump(comp->emit, l_end));
        }

        (comp->emit_method_table->label_assign(comp->emit, l_fail));
    }


    mp_parse_node_t *pn_elif;
    int n_elif = mp_parse_node_extract_list(&pns->nodes[2], PN_if_stmt_elif_list, &pn_elif);
    for (int i = 0; i < n_elif; i++) {
        
# 1354 "../py/compile.c" 3
       ((
# 1354 "../py/compile.c"
       ((pn_elif[i]) != (0) && ((pn_elif[i]) & 3) == 0 && (((mp_parse_node_struct_t*)(pn_elif[i]))->kind_num_nodes & 0xff) == (PN_if_stmt_elif))
# 1354 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 1354, __func__, 
# 1354 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT_KIND(pn_elif[i], PN_if_stmt_elif)"
# 1354 "../py/compile.c" 3
       ))
# 1354 "../py/compile.c"
                                                                        ;
        mp_parse_node_struct_t *pns_elif = (mp_parse_node_struct_t*)pn_elif[i];


        if (!mp_parse_node_is_const_false(pns_elif->nodes[0])) {
            uint l_fail = comp_next_label(comp);
            c_if_cond(comp, pns_elif->nodes[0], 
# 1360 "../py/compile.c" 3 4
                                               0
# 1360 "../py/compile.c"
                                                    , l_fail);

            compile_node(comp, pns_elif->nodes[1]);


            if (mp_parse_node_is_const_true(pns_elif->nodes[0])) {
                goto done;
            }


            if (!(comp->emit_method_table->last_emit_was_return_value(comp->emit))) {
                (comp->emit_method_table->jump(comp->emit, l_end));
            }
            (comp->emit_method_table->label_assign(comp->emit, l_fail));
        }
    }


    compile_node(comp, pns->nodes[3]);

done:
    (comp->emit_method_table->label_assign(comp->emit, l_end));
}
# 1399 "../py/compile.c"
static void compile_while_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {
    uint16_t old_break_label = comp->break_label; uint16_t old_continue_label = comp->continue_label; uint16_t old_break_continue_except_level = comp->break_continue_except_level; uint break_label = comp_next_label(comp); uint continue_label = comp_next_label(comp); comp->break_label = break_label; comp->continue_label = continue_label; comp->break_continue_except_level = comp->cur_except_level;

    if (!mp_parse_node_is_const_false(pns->nodes[0])) {
        uint top_label = comp_next_label(comp);
        if (!mp_parse_node_is_const_true(pns->nodes[0])) {
            (comp->emit_method_table->jump(comp->emit, continue_label));
        }
        (comp->emit_method_table->label_assign(comp->emit, top_label));
        compile_node(comp, pns->nodes[1]);
        (comp->emit_method_table->label_assign(comp->emit, continue_label));
        c_if_cond(comp, pns->nodes[0], 
# 1410 "../py/compile.c" 3 4
                                      1
# 1410 "../py/compile.c"
                                          , top_label);
    }


    comp->break_label = old_break_label; comp->continue_label = old_continue_label; comp->break_continue_except_level = old_break_continue_except_level;

    compile_node(comp, pns->nodes[2]);

    (comp->emit_method_table->label_assign(comp->emit, break_label));
}
# 1437 "../py/compile.c"
static void compile_for_stmt_optimised_range(compiler_t *comp, mp_parse_node_t pn_var, mp_parse_node_t pn_start, mp_parse_node_t pn_end, mp_parse_node_t pn_step, mp_parse_node_t pn_body, mp_parse_node_t pn_else) {
    uint16_t old_break_label = comp->break_label; uint16_t old_continue_label = comp->continue_label; uint16_t old_break_continue_except_level = comp->break_continue_except_level; uint break_label = comp_next_label(comp); uint continue_label = comp_next_label(comp); comp->break_label = break_label; comp->continue_label = continue_label; comp->break_continue_except_level = comp->cur_except_level;

    uint top_label = comp_next_label(comp);
    uint entry_label = comp_next_label(comp);


    
# 1444 "../py/compile.c" 3 4
   _Bool 
# 1444 "../py/compile.c"
        end_on_stack = !(((pn_end) & 0x1) == (0x1));
    if (end_on_stack) {
        compile_node(comp, pn_end);
    }


    compile_node(comp, pn_start);

    (comp->emit_method_table->jump(comp->emit, entry_label));
    (comp->emit_method_table->label_assign(comp->emit, top_label));


    (comp->emit_method_table->dup_top(comp->emit));
    c_assign(comp, pn_var, ASSIGN_STORE);


    compile_node(comp, pn_body);

    (comp->emit_method_table->label_assign(comp->emit, continue_label));


    compile_node(comp, pn_step);
    (comp->emit_method_table->binary_op(comp->emit, MP_BINARY_OP_INPLACE_ADD));

    (comp->emit_method_table->label_assign(comp->emit, entry_label));


    if (end_on_stack) {
        (comp->emit_method_table->dup_top_two(comp->emit));
        (comp->emit_method_table->rot_two(comp->emit));
    } else {
        (comp->emit_method_table->dup_top(comp->emit));
        compile_node(comp, pn_end);
    }
    
# 1478 "../py/compile.c" 3
   ((
# 1478 "../py/compile.c"
   (((pn_step) & 0x1) == (0x1))
# 1478 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 1478, __func__, 
# 1478 "../py/compile.c"
   "MP_PARSE_NODE_IS_SMALL_INT(pn_step)"
# 1478 "../py/compile.c" 3
   ))
# 1478 "../py/compile.c"
                                              ;
    if ((((mp_int_t)(intptr_t)(pn_step)) >> 1) >= 0) {
        (comp->emit_method_table->binary_op(comp->emit, MP_BINARY_OP_LESS));
    } else {
        (comp->emit_method_table->binary_op(comp->emit, MP_BINARY_OP_MORE));
    }
    (comp->emit_method_table->pop_jump_if(comp->emit, 
# 1484 "../py/compile.c" 3 4
   1
# 1484 "../py/compile.c"
   , top_label));


    comp->break_label = old_break_label; comp->continue_label = old_continue_label; comp->break_continue_except_level = old_break_continue_except_level;



    uint end_label = 0;
    if (!((pn_else) == (0))) {

        (comp->emit_method_table->pop_top(comp->emit));
        if (end_on_stack) {
            (comp->emit_method_table->pop_top(comp->emit));
        }
        compile_node(comp, pn_else);
        end_label = comp_next_label(comp);
        (comp->emit_method_table->jump(comp->emit, end_label));
        (comp->emit_method_table->adjust_stack_size(comp->emit, 1 + end_on_stack));
    }

    (comp->emit_method_table->label_assign(comp->emit, break_label));


    (comp->emit_method_table->pop_top(comp->emit));


    if (end_on_stack) {
        (comp->emit_method_table->pop_top(comp->emit));
    }

    if (!((pn_else) == (0))) {
        (comp->emit_method_table->label_assign(comp->emit, end_label));
    }
}

static void compile_for_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {



    if ( (((pns->nodes[0]) & 0x0f) == (0x02)) && ((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[1]))->kind_num_nodes & 0xff) == (PN_atom_expr_normal))) {
        mp_parse_node_struct_t *pns_it = (mp_parse_node_struct_t*)pns->nodes[1];
        if ((((pns_it->nodes[0]) & 0x0f) == (0x02))
            && (((uintptr_t)(pns_it->nodes[0])) >> 4) == MP_QSTR_range
            && (((mp_parse_node_struct_t*)pns_it->nodes[1])->kind_num_nodes & 0xff) == PN_trailer_paren) {
            mp_parse_node_t pn_range_args = ((mp_parse_node_struct_t*)pns_it->nodes[1])->nodes[0];
            mp_parse_node_t *args;
            int n_args = mp_parse_node_extract_list(&pn_range_args, PN_arglist, &args);
            mp_parse_node_t pn_range_start;
            mp_parse_node_t pn_range_end;
            mp_parse_node_t pn_range_step;
            
# 1534 "../py/compile.c" 3 4
           _Bool 
# 1534 "../py/compile.c"
                optimize = 
# 1534 "../py/compile.c" 3 4
                           0
# 1534 "../py/compile.c"
                                ;
            if (1 <= n_args && n_args <= 3) {
                optimize = 
# 1536 "../py/compile.c" 3 4
                          1
# 1536 "../py/compile.c"
                              ;
                if (n_args == 1) {
                    pn_range_start = mp_parse_node_new_small_int(0);
                    pn_range_end = args[0];
                    pn_range_step = mp_parse_node_new_small_int(1);
                } else if (n_args == 2) {
                    pn_range_start = args[0];
                    pn_range_end = args[1];
                    pn_range_step = mp_parse_node_new_small_int(1);
                } else {
                    pn_range_start = args[0];
                    pn_range_end = args[1];
                    pn_range_step = args[2];

                    if (!(((pn_range_step) & 0x1) == (0x1))
                        || (((mp_int_t)(intptr_t)(pn_range_step)) >> 1) == 0) {
                        optimize = 
# 1552 "../py/compile.c" 3 4
                                  0
# 1552 "../py/compile.c"
                                       ;
                    }
                }

                if (optimize && ((pn_range_start) != (0) && ((pn_range_start) & 3) == 0)) {
                    int k = (((mp_parse_node_struct_t*)pn_range_start)->kind_num_nodes & 0xff);
                    if (k == PN_arglist_star || k == PN_arglist_dbl_star || k == PN_argument) {
                        optimize = 
# 1559 "../py/compile.c" 3 4
                                  0
# 1559 "../py/compile.c"
                                       ;
                    }
                }
                if (optimize && ((pn_range_end) != (0) && ((pn_range_end) & 3) == 0)) {
                    int k = (((mp_parse_node_struct_t*)pn_range_end)->kind_num_nodes & 0xff);
                    if (k == PN_arglist_star || k == PN_arglist_dbl_star || k == PN_argument) {
                        optimize = 
# 1565 "../py/compile.c" 3 4
                                  0
# 1565 "../py/compile.c"
                                       ;
                    }
                }
            }
            if (optimize) {
                compile_for_stmt_optimised_range(comp, pns->nodes[0], pn_range_start, pn_range_end, pn_range_step, pns->nodes[2], pns->nodes[3]);
                return;
            }
        }
    }

    uint16_t old_break_label = comp->break_label; uint16_t old_continue_label = comp->continue_label; uint16_t old_break_continue_except_level = comp->break_continue_except_level; uint break_label = comp_next_label(comp); uint continue_label = comp_next_label(comp); comp->break_label = break_label; comp->continue_label = continue_label; comp->break_continue_except_level = comp->cur_except_level;
    comp->break_label |= (0x8000);

    uint pop_label = comp_next_label(comp);

    compile_node(comp, pns->nodes[1]);
    (comp->emit_method_table->get_iter(comp->emit, 
# 1582 "../py/compile.c" 3 4
   1
# 1582 "../py/compile.c"
   ));
    (comp->emit_method_table->label_assign(comp->emit, continue_label));
    (comp->emit_method_table->for_iter(comp->emit, pop_label));
    c_assign(comp, pns->nodes[0], ASSIGN_STORE);
    compile_node(comp, pns->nodes[2]);
    if (!(comp->emit_method_table->last_emit_was_return_value(comp->emit))) {
        (comp->emit_method_table->jump(comp->emit, continue_label));
    }
    (comp->emit_method_table->label_assign(comp->emit, pop_label));
    (comp->emit_method_table->for_iter_end(comp->emit));


    comp->break_label = old_break_label; comp->continue_label = old_continue_label; comp->break_continue_except_level = old_break_continue_except_level;

    compile_node(comp, pns->nodes[3]);

    (comp->emit_method_table->label_assign(comp->emit, break_label));
}

static void compile_try_except(compiler_t *comp, mp_parse_node_t pn_body, int n_except, mp_parse_node_t *pn_excepts, mp_parse_node_t pn_else) {

    uint l1 = comp_next_label(comp);
    uint success_label = comp_next_label(comp);

    compile_increase_except_level(comp, l1, (1));

    compile_node(comp, pn_body);
    (comp->emit_method_table->pop_except_jump(comp->emit, success_label, 
# 1609 "../py/compile.c" 3 4
   0
# 1609 "../py/compile.c"
   ));

    (comp->emit_method_table->label_assign(comp->emit, l1));
    (comp->emit_method_table->start_except_handler(comp->emit));



    uint l2 = comp_next_label(comp);

    for (int i = 0; i < n_except; i++) {
        
# 1619 "../py/compile.c" 3
       ((
# 1619 "../py/compile.c"
       ((pn_excepts[i]) != (0) && ((pn_excepts[i]) & 3) == 0 && (((mp_parse_node_struct_t*)(pn_excepts[i]))->kind_num_nodes & 0xff) == (PN_try_stmt_except))
# 1619 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 1619, __func__, 
# 1619 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT_KIND(pn_excepts[i], PN_try_stmt_except)"
# 1619 "../py/compile.c" 3
       ))
# 1619 "../py/compile.c"
                                                                              ;
        mp_parse_node_struct_t *pns_except = (mp_parse_node_struct_t*)pn_excepts[i];

        qstr qstr_exception_local = 0;
        uint end_finally_label = comp_next_label(comp);




        if (((pns_except->nodes[0]) == (0))) {

            if (i + 1 != n_except) {
                compile_syntax_error(comp, pn_excepts[i], "default 'except' must be last");
                compile_decrease_except_level(comp);
                return;
            }
        } else {

            mp_parse_node_t pns_exception_expr = pns_except->nodes[0];
            if (((pns_exception_expr) != (0) && ((pns_exception_expr) & 3) == 0)) {
                mp_parse_node_struct_t *pns3 = (mp_parse_node_struct_t*)pns_exception_expr;
                if (((pns3)->kind_num_nodes & 0xff) == PN_try_stmt_as_name) {

                    pns_exception_expr = pns3->nodes[0];
                    qstr_exception_local = (((uintptr_t)(pns3->nodes[1])) >> 4);
                }
            }
            (comp->emit_method_table->dup_top(comp->emit));
            compile_node(comp, pns_exception_expr);
            (comp->emit_method_table->binary_op(comp->emit, MP_BINARY_OP_EXCEPTION_MATCH));
            (comp->emit_method_table->pop_jump_if(comp->emit, 
# 1649 "../py/compile.c" 3 4
           0
# 1649 "../py/compile.c"
           , end_finally_label));
        }


        if (qstr_exception_local == 0) {
            (comp->emit_method_table->pop_top(comp->emit));
        } else {
            compile_store_id(comp, qstr_exception_local);
        }
# 1668 "../py/compile.c"
        uint l3 = 0;
        if (qstr_exception_local != 0) {
            l3 = comp_next_label(comp);
            compile_increase_except_level(comp, l3, (2));
        }
        compile_node(comp, pns_except->nodes[1]);
        if (qstr_exception_local != 0) {
            (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
            (comp->emit_method_table->label_assign(comp->emit, l3));
            (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
            compile_store_id(comp, qstr_exception_local);
            compile_delete_id(comp, qstr_exception_local);
            compile_decrease_except_level(comp);
        }

        (comp->emit_method_table->pop_except_jump(comp->emit, l2, 
# 1683 "../py/compile.c" 3 4
       1
# 1683 "../py/compile.c"
       ));
        (comp->emit_method_table->label_assign(comp->emit, end_finally_label));
        (comp->emit_method_table->adjust_stack_size(comp->emit, 1));
    }

    compile_decrease_except_level(comp);
    (comp->emit_method_table->end_except_handler(comp->emit));

    (comp->emit_method_table->label_assign(comp->emit, success_label));
    compile_node(comp, pn_else);
    (comp->emit_method_table->label_assign(comp->emit, l2));
}

static void compile_try_finally(compiler_t *comp, mp_parse_node_t pn_body, int n_except, mp_parse_node_t *pn_except, mp_parse_node_t pn_else, mp_parse_node_t pn_finally) {
    uint l_finally_block = comp_next_label(comp);

    compile_increase_except_level(comp, l_finally_block, (2));

    if (n_except == 0) {
        
# 1702 "../py/compile.c" 3
       ((
# 1702 "../py/compile.c"
       ((pn_else) == (0))
# 1702 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 1702, __func__, 
# 1702 "../py/compile.c"
       "MP_PARSE_NODE_IS_NULL(pn_else)"
# 1702 "../py/compile.c" 3
       ))
# 1702 "../py/compile.c"
                                             ;
        (comp->emit_method_table->adjust_stack_size(comp->emit, 3));
        compile_node(comp, pn_body);
        (comp->emit_method_table->adjust_stack_size(comp->emit, -3));
    } else {
        compile_try_except(comp, pn_body, n_except, pn_except, pn_else);
    }
    (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
    (comp->emit_method_table->label_assign(comp->emit, l_finally_block));
    compile_node(comp, pn_finally);

    compile_decrease_except_level(comp);
}

static void compile_try_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {
    
# 1717 "../py/compile.c" 3
   ((
# 1717 "../py/compile.c"
   ((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0)
# 1717 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 1717, __func__, 
# 1717 "../py/compile.c"
   "MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])"
# 1717 "../py/compile.c" 3
   ))
# 1717 "../py/compile.c"
                                                 ;
    {
        mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t*)pns->nodes[1];
        if (((pns2)->kind_num_nodes & 0xff) == PN_try_stmt_finally) {

            compile_try_finally(comp, pns->nodes[0], 0, 
# 1722 "../py/compile.c" 3 4
                                                       ((void *)0)
# 1722 "../py/compile.c"
                                                           , (0), pns2->nodes[0]);
        } else if (((pns2)->kind_num_nodes & 0xff) == PN_try_stmt_except_and_more) {

            mp_parse_node_t *pn_excepts;
            int n_except = mp_parse_node_extract_list(&pns2->nodes[0], PN_try_stmt_except_list, &pn_excepts);
            if (((pns2->nodes[2]) == (0))) {

                compile_try_except(comp, pns->nodes[0], n_except, pn_excepts, pns2->nodes[1]);
            } else {

                compile_try_finally(comp, pns->nodes[0], n_except, pn_excepts, pns2->nodes[1], ((mp_parse_node_struct_t*)pns2->nodes[2])->nodes[0]);
            }
        } else {

            mp_parse_node_t *pn_excepts;
            int n_except = mp_parse_node_extract_list(&pns->nodes[1], PN_try_stmt_except_list, &pn_excepts);
            compile_try_except(comp, pns->nodes[0], n_except, pn_excepts, (0));
        }
    }
}

static void compile_with_stmt_helper(compiler_t *comp, int n, mp_parse_node_t *nodes, mp_parse_node_t body) {
    if (n == 0) {

        compile_node(comp, body);
    } else {
        uint l_end = comp_next_label(comp);
        if (((nodes[0]) != (0) && ((nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(nodes[0]))->kind_num_nodes & 0xff) == (PN_with_item))) {

            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)nodes[0];
            compile_node(comp, pns->nodes[0]);
            compile_increase_except_level(comp, l_end, (0));
            c_assign(comp, pns->nodes[1], ASSIGN_STORE);
        } else {

            compile_node(comp, nodes[0]);
            compile_increase_except_level(comp, l_end, (0));
            (comp->emit_method_table->pop_top(comp->emit));
        }

        compile_with_stmt_helper(comp, n - 1, nodes + 1, body);

        (comp->emit_method_table->with_cleanup(comp->emit, l_end));
        reserve_labels_for_native(comp, 3);
        compile_decrease_except_level(comp);
    }
}

static void compile_with_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {

    mp_parse_node_t *nodes;
    int n = mp_parse_node_extract_list(&pns->nodes[0], PN_with_stmt_list, &nodes);
    
# 1774 "../py/compile.c" 3
   ((
# 1774 "../py/compile.c"
   n > 0
# 1774 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 1774, __func__, 
# 1774 "../py/compile.c"
   "n > 0"
# 1774 "../py/compile.c" 3
   ))
# 1774 "../py/compile.c"
                ;


    compile_with_stmt_helper(comp, n, nodes, pns->nodes[1]);
}

static void compile_yield_from(compiler_t *comp) {
    (comp->emit_method_table->get_iter(comp->emit, 
# 1781 "../py/compile.c" 3 4
   0
# 1781 "../py/compile.c"
   ));
    (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
    (comp->emit_method_table->yield(comp->emit, (1)));
    reserve_labels_for_native(comp, 3);
}


static void compile_await_object_method(compiler_t *comp, qstr method) {
    (comp->emit_method_table->load_method(comp->emit, method, 
# 1789 "../py/compile.c" 3 4
   0
# 1789 "../py/compile.c"
   ));
    (comp->emit_method_table->call_method(comp->emit, 0, 0, 0));
    compile_yield_from(comp);
}

static void compile_async_for_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {


    qstr context = (((uintptr_t)(pns->nodes[1])) >> 4);
    uint while_else_label = comp_next_label(comp);
    uint try_exception_label = comp_next_label(comp);
    uint try_else_label = comp_next_label(comp);
    uint try_finally_label = comp_next_label(comp);

    compile_node(comp, pns->nodes[1]);
    compile_await_object_method(comp, MP_QSTR___aiter__);
    compile_store_id(comp, context);

    uint16_t old_break_label = comp->break_label; uint16_t old_continue_label = comp->continue_label; uint16_t old_break_continue_except_level = comp->break_continue_except_level; uint break_label = comp_next_label(comp); uint continue_label = comp_next_label(comp); comp->break_label = break_label; comp->continue_label = continue_label; comp->break_continue_except_level = comp->cur_except_level;

    (comp->emit_method_table->label_assign(comp->emit, continue_label));

    compile_increase_except_level(comp, try_exception_label, (1));

    compile_load_id(comp, context);
    compile_await_object_method(comp, MP_QSTR___anext__);
    c_assign(comp, pns->nodes[0], ASSIGN_STORE);
    (comp->emit_method_table->pop_except_jump(comp->emit, try_else_label, 
# 1816 "../py/compile.c" 3 4
   0
# 1816 "../py/compile.c"
   ));

    (comp->emit_method_table->label_assign(comp->emit, try_exception_label));
    (comp->emit_method_table->start_except_handler(comp->emit));
    (comp->emit_method_table->dup_top(comp->emit));
    (comp->emit_method_table->load_id.global(comp->emit, MP_QSTR_StopAsyncIteration, (1)));
    (comp->emit_method_table->binary_op(comp->emit, MP_BINARY_OP_EXCEPTION_MATCH));
    (comp->emit_method_table->pop_jump_if(comp->emit, 
# 1823 "../py/compile.c" 3 4
   0
# 1823 "../py/compile.c"
   , try_finally_label));
    (comp->emit_method_table->pop_top(comp->emit));
    (comp->emit_method_table->pop_except_jump(comp->emit, while_else_label, 
# 1825 "../py/compile.c" 3 4
   1
# 1825 "../py/compile.c"
   ));

    (comp->emit_method_table->label_assign(comp->emit, try_finally_label));
    (comp->emit_method_table->adjust_stack_size(comp->emit, 1));
    compile_decrease_except_level(comp);
    (comp->emit_method_table->end_except_handler(comp->emit));

    (comp->emit_method_table->label_assign(comp->emit, try_else_label));
    compile_node(comp, pns->nodes[2]);

    (comp->emit_method_table->jump(comp->emit, continue_label));

    comp->break_label = old_break_label; comp->continue_label = old_continue_label; comp->break_continue_except_level = old_break_continue_except_level;

    (comp->emit_method_table->label_assign(comp->emit, while_else_label));
    compile_node(comp, pns->nodes[3]);

    (comp->emit_method_table->label_assign(comp->emit, break_label));
}

static void compile_async_with_stmt_helper(compiler_t *comp, int n, mp_parse_node_t *nodes, mp_parse_node_t body) {
    if (n == 0) {

        compile_node(comp, body);
    } else {
        uint l_finally_block = comp_next_label(comp);
        uint l_aexit_no_exc = comp_next_label(comp);
        uint l_ret_unwind_jump = comp_next_label(comp);
        uint l_end = comp_next_label(comp);

        if (((nodes[0]) != (0) && ((nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(nodes[0]))->kind_num_nodes & 0xff) == (PN_with_item))) {

            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)nodes[0];
            compile_node(comp, pns->nodes[0]);
            (comp->emit_method_table->dup_top(comp->emit));
            compile_await_object_method(comp, MP_QSTR___aenter__);
            c_assign(comp, pns->nodes[1], ASSIGN_STORE);
        } else {

            compile_node(comp, nodes[0]);
            (comp->emit_method_table->dup_top(comp->emit));
            compile_await_object_method(comp, MP_QSTR___aenter__);
            (comp->emit_method_table->pop_top(comp->emit));
        }






        compile_increase_except_level(comp, l_finally_block, (2));


        (comp->emit_method_table->adjust_stack_size(comp->emit, 3));
        compile_async_with_stmt_helper(comp, n - 1, nodes + 1, body);
        (comp->emit_method_table->adjust_stack_size(comp->emit, -3));
# 1891 "../py/compile.c"
        (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
        (comp->emit_method_table->rot_two(comp->emit));
        (comp->emit_method_table->jump(comp->emit, l_aexit_no_exc));



        (comp->emit_method_table->label_assign(comp->emit, l_finally_block));


        (comp->emit_method_table->dup_top(comp->emit));
        (comp->emit_method_table->load_id.global(comp->emit, MP_QSTR_BaseException, (1)));
        (comp->emit_method_table->binary_op(comp->emit, MP_BINARY_OP_EXCEPTION_MATCH));
        (comp->emit_method_table->pop_jump_if(comp->emit, 
# 1903 "../py/compile.c" 3 4
       0
# 1903 "../py/compile.c"
       , l_ret_unwind_jump));



        (comp->emit_method_table->dup_top(comp->emit));
        (comp->emit_method_table->rot_three(comp->emit));
        (comp->emit_method_table->rot_two(comp->emit));
        (comp->emit_method_table->load_method(comp->emit, MP_QSTR___aexit__, 
# 1910 "../py/compile.c" 3 4
       0
# 1910 "../py/compile.c"
       ));
        (comp->emit_method_table->rot_three(comp->emit));
        (comp->emit_method_table->rot_three(comp->emit));
        (comp->emit_method_table->dup_top(comp->emit));

        (comp->emit_method_table->attr(comp->emit, MP_QSTR___class__, (0)));





        (comp->emit_method_table->rot_two(comp->emit));
        (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));

        (comp->emit_method_table->call_method(comp->emit, 3, 0, 0));
        compile_yield_from(comp);
        (comp->emit_method_table->pop_jump_if(comp->emit, 
# 1926 "../py/compile.c" 3 4
       0
# 1926 "../py/compile.c"
       , l_end));
        (comp->emit_method_table->pop_top(comp->emit));
        (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
        (comp->emit_method_table->jump(comp->emit, l_end));
        (comp->emit_method_table->adjust_stack_size(comp->emit, 2));



        (comp->emit_method_table->label_assign(comp->emit, l_ret_unwind_jump));
        (comp->emit_method_table->rot_three(comp->emit));
        (comp->emit_method_table->rot_three(comp->emit));
        (comp->emit_method_table->label_assign(comp->emit, l_aexit_no_exc));
        (comp->emit_method_table->load_method(comp->emit, MP_QSTR___aexit__, 
# 1938 "../py/compile.c" 3 4
       0
# 1938 "../py/compile.c"
       ));
        (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
        (comp->emit_method_table->dup_top(comp->emit));
        (comp->emit_method_table->dup_top(comp->emit));
        (comp->emit_method_table->call_method(comp->emit, 3, 0, 0));
        compile_yield_from(comp);
        (comp->emit_method_table->pop_top(comp->emit));
        (comp->emit_method_table->adjust_stack_size(comp->emit, -1));






        (comp->emit_method_table->label_assign(comp->emit, l_end));
        compile_decrease_except_level(comp);
    }
}

static void compile_async_with_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {

    mp_parse_node_t *nodes;
    int n = mp_parse_node_extract_list(&pns->nodes[0], PN_with_stmt_list, &nodes);
    
# 1961 "../py/compile.c" 3
   ((
# 1961 "../py/compile.c"
   n > 0
# 1961 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 1961, __func__, 
# 1961 "../py/compile.c"
   "n > 0"
# 1961 "../py/compile.c" 3
   ))
# 1961 "../py/compile.c"
                ;


    compile_async_with_stmt_helper(comp, n, nodes, pns->nodes[1]);
}

static void compile_async_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {
    
# 1968 "../py/compile.c" 3
   ((
# 1968 "../py/compile.c"
   ((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0)
# 1968 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 1968, __func__, 
# 1968 "../py/compile.c"
   "MP_PARSE_NODE_IS_STRUCT(pns->nodes[0])"
# 1968 "../py/compile.c" 3
   ))
# 1968 "../py/compile.c"
                                                 ;
    mp_parse_node_struct_t *pns0 = (mp_parse_node_struct_t*)pns->nodes[0];
    if (((pns0)->kind_num_nodes & 0xff) == PN_funcdef) {

        compile_funcdef(comp, pns0);
        scope_t *fscope = (scope_t*)pns0->nodes[4];
        fscope->scope_flags |= (0x01);
    } else if (((pns0)->kind_num_nodes & 0xff) == PN_for_stmt) {

        compile_async_for_stmt(comp, pns0);
    } else {

        
# 1980 "../py/compile.c" 3
       ((
# 1980 "../py/compile.c"
       ((pns0)->kind_num_nodes & 0xff) == PN_with_stmt
# 1980 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 1980, __func__, 
# 1980 "../py/compile.c"
       "MP_PARSE_NODE_STRUCT_KIND(pns0) == PN_with_stmt"
# 1980 "../py/compile.c" 3
       ))
# 1980 "../py/compile.c"
                                                              ;
        compile_async_with_stmt(comp, pns0);
    }
}


static void compile_expr_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (((pns->nodes[1]) == (0))) {
        if (comp->is_repl && comp->scope_cur->kind == SCOPE_MODULE) {

            compile_load_id(comp, MP_QSTR___repl_print__);
            compile_node(comp, pns->nodes[0]);
            (comp->emit_method_table->call_function(comp->emit, 1, 0, 0));
            (comp->emit_method_table->pop_top(comp->emit));

        } else {

            if ((((pns->nodes[0]) & 3) && !(((pns->nodes[0]) & 0x0f) == (0x02)))
                || ((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_const_object))) {

            } else {
                compile_node(comp, pns->nodes[0]);
                (comp->emit_method_table->pop_top(comp->emit));
            }
        }
    } else if (((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0)) {
        mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t*)pns->nodes[1];
        int kind = ((pns1)->kind_num_nodes & 0xff);
        if (kind == PN_expr_stmt_augassign) {
            c_assign(comp, pns->nodes[0], ASSIGN_AUG_LOAD);
            compile_node(comp, pns1->nodes[1]);
            
# 2011 "../py/compile.c" 3
           ((
# 2011 "../py/compile.c"
           (((pns1->nodes[0]) & 0x0f) == (0x0e))
# 2011 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 2011, __func__, 
# 2011 "../py/compile.c"
           "MP_PARSE_NODE_IS_TOKEN(pns1->nodes[0])"
# 2011 "../py/compile.c" 3
           ))
# 2011 "../py/compile.c"
                                                         ;
            mp_token_kind_t tok = (((uintptr_t)(pns1->nodes[0])) >> 4);
            mp_binary_op_t op = MP_BINARY_OP_INPLACE_OR + (tok - MP_TOKEN_DEL_PIPE_EQUAL);
            (comp->emit_method_table->binary_op(comp->emit, op));
            c_assign(comp, pns->nodes[0], ASSIGN_AUG_STORE);
        } else if (kind == PN_expr_stmt_assign_list) {
            int rhs = ((pns1)->kind_num_nodes >> 8) - 1;
            compile_node(comp, pns1->nodes[rhs]);

            if (rhs > 0) {
                (comp->emit_method_table->dup_top(comp->emit));
            }
            c_assign(comp, pns->nodes[0], ASSIGN_STORE);
            for (int i = 0; i < rhs; i++) {
                if (i + 1 < rhs) {
                    (comp->emit_method_table->dup_top(comp->emit));
                }
                c_assign(comp, pns1->nodes[i], ASSIGN_STORE);
            }
        } else {
        plain_assign:

            if (((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[1]))->kind_num_nodes & 0xff) == (PN_testlist_star_expr))
                && ((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_testlist_star_expr))) {
                mp_parse_node_struct_t *pns0 = (mp_parse_node_struct_t*)pns->nodes[0];
                pns1 = (mp_parse_node_struct_t*)pns->nodes[1];
                uint32_t n_pns0 = ((pns0)->kind_num_nodes >> 8);




                if (n_pns0 == ((pns1)->kind_num_nodes >> 8)
                    && (n_pns0 == 2

                        || n_pns0 == 3

                        )
                    && !((pns0->nodes[0]) != (0) && ((pns0->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns0->nodes[0]))->kind_num_nodes & 0xff) == (PN_star_expr))
                    && !((pns0->nodes[1]) != (0) && ((pns0->nodes[1]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns0->nodes[1]))->kind_num_nodes & 0xff) == (PN_star_expr))

                    && (n_pns0 == 2 || !((pns0->nodes[2]) != (0) && ((pns0->nodes[2]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns0->nodes[2]))->kind_num_nodes & 0xff) == (PN_star_expr)))

                    ) {

                    compile_node(comp, pns1->nodes[0]);
                    compile_node(comp, pns1->nodes[1]);

                    if (n_pns0 == 3) {
                        compile_node(comp, pns1->nodes[2]);
                        (comp->emit_method_table->rot_three(comp->emit));
                    }

                    (comp->emit_method_table->rot_two(comp->emit));
                    c_assign(comp, pns0->nodes[0], ASSIGN_STORE);
                    c_assign(comp, pns0->nodes[1], ASSIGN_STORE);

                    if (n_pns0 == 3) {
                        c_assign(comp, pns0->nodes[2], ASSIGN_STORE);
                    }

                    return;
                }
            }


            compile_node(comp, pns->nodes[1]);
            c_assign(comp, pns->nodes[0], ASSIGN_STORE);
        }
    } else {
        goto plain_assign;
    }
}

static void compile_test_if_expr(compiler_t *comp, mp_parse_node_struct_t *pns) {
    
# 2085 "../py/compile.c" 3
   ((
# 2085 "../py/compile.c"
   ((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[1]))->kind_num_nodes & 0xff) == (PN_test_if_else))
# 2085 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 2085, __func__, 
# 2085 "../py/compile.c"
   "MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_test_if_else)"
# 2085 "../py/compile.c" 3
   ))
# 2085 "../py/compile.c"
                                                                       ;
    mp_parse_node_struct_t *pns_test_if_else = (mp_parse_node_struct_t*)pns->nodes[1];

    uint l_fail = comp_next_label(comp);
    uint l_end = comp_next_label(comp);
    c_if_cond(comp, pns_test_if_else->nodes[0], 
# 2090 "../py/compile.c" 3 4
                                               0
# 2090 "../py/compile.c"
                                                    , l_fail);
    compile_node(comp, pns->nodes[0]);
    (comp->emit_method_table->jump(comp->emit, l_end));
    (comp->emit_method_table->label_assign(comp->emit, l_fail));
    (comp->emit_method_table->adjust_stack_size(comp->emit, -1));
    compile_node(comp, pns_test_if_else->nodes[1]);
    (comp->emit_method_table->label_assign(comp->emit, l_end));
}

static void compile_lambdef(compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->pass == MP_PASS_SCOPE) {

        scope_t *s = scope_new_and_link(comp, SCOPE_LAMBDA, (mp_parse_node_t)pns, comp->scope_cur->emit_options);

        pns->nodes[2] = (mp_parse_node_t)s;
    }


    scope_t *this_scope = (scope_t*)pns->nodes[2];


    compile_funcdef_lambdef(comp, this_scope, pns->nodes[0], PN_varargslist);
}

static void compile_or_and_test(compiler_t *comp, mp_parse_node_struct_t *pns) {
    
# 2115 "../py/compile.c" 3 4
   _Bool 
# 2115 "../py/compile.c"
        cond = ((pns)->kind_num_nodes & 0xff) == PN_or_test;
    uint l_end = comp_next_label(comp);
    int n = ((pns)->kind_num_nodes >> 8);
    for (int i = 0; i < n; i += 1) {
        compile_node(comp, pns->nodes[i]);
        if (i + 1 < n) {
            (comp->emit_method_table->jump_if_or_pop(comp->emit, cond, l_end));
        }
    }
    (comp->emit_method_table->label_assign(comp->emit, l_end));
}

static void compile_not_test_2(compiler_t *comp, mp_parse_node_struct_t *pns) {
    compile_node(comp, pns->nodes[0]);
    (comp->emit_method_table->unary_op(comp->emit, MP_UNARY_OP_NOT));
}

static void compile_comparison(compiler_t *comp, mp_parse_node_struct_t *pns) {
    int num_nodes = ((pns)->kind_num_nodes >> 8);
    compile_node(comp, pns->nodes[0]);
    
# 2135 "../py/compile.c" 3 4
   _Bool 
# 2135 "../py/compile.c"
        multi = (num_nodes > 3);
    uint l_fail = 0;
    if (multi) {
        l_fail = comp_next_label(comp);
    }
    for (int i = 1; i + 1 < num_nodes; i += 2) {
        compile_node(comp, pns->nodes[i + 1]);
        if (i + 2 < num_nodes) {
            (comp->emit_method_table->dup_top(comp->emit));
            (comp->emit_method_table->rot_three(comp->emit));
        }
        if ((((pns->nodes[i]) & 0x0f) == (0x0e))) {
            mp_token_kind_t tok = (((uintptr_t)(pns->nodes[i])) >> 4);
            mp_binary_op_t op;
            if (tok == MP_TOKEN_KW_IN) {
                op = MP_BINARY_OP_IN;
            } else {
                op = MP_BINARY_OP_LESS + (tok - MP_TOKEN_OP_LESS);
            }
            (comp->emit_method_table->binary_op(comp->emit, op));
        } else {
            
# 2156 "../py/compile.c" 3
           ((
# 2156 "../py/compile.c"
           ((pns->nodes[i]) != (0) && ((pns->nodes[i]) & 3) == 0)
# 2156 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 2156, __func__, 
# 2156 "../py/compile.c"
           "MP_PARSE_NODE_IS_STRUCT(pns->nodes[i])"
# 2156 "../py/compile.c" 3
           ))
# 2156 "../py/compile.c"
                                                         ;
            mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t*)pns->nodes[i];
            int kind = ((pns2)->kind_num_nodes & 0xff);
            if (kind == PN_comp_op_not_in) {
                (comp->emit_method_table->binary_op(comp->emit, MP_BINARY_OP_NOT_IN));
            } else {
                
# 2162 "../py/compile.c" 3
               ((
# 2162 "../py/compile.c"
               kind == PN_comp_op_is
# 2162 "../py/compile.c" 3
               ) ? (void)0 : __assert_func ("../py/compile.c", 2162, __func__, 
# 2162 "../py/compile.c"
               "kind == PN_comp_op_is"
# 2162 "../py/compile.c" 3
               ))
# 2162 "../py/compile.c"
                                            ;
                if (((pns2->nodes[0]) == (0))) {
                    (comp->emit_method_table->binary_op(comp->emit, MP_BINARY_OP_IS));
                } else {
                    (comp->emit_method_table->binary_op(comp->emit, MP_BINARY_OP_IS_NOT));
                }
            }
        }
        if (i + 2 < num_nodes) {
            (comp->emit_method_table->jump_if_or_pop(comp->emit, 
# 2171 "../py/compile.c" 3 4
           0
# 2171 "../py/compile.c"
           , l_fail));
        }
    }
    if (multi) {
        uint l_end = comp_next_label(comp);
        (comp->emit_method_table->jump(comp->emit, l_end));
        (comp->emit_method_table->label_assign(comp->emit, l_fail));
        (comp->emit_method_table->adjust_stack_size(comp->emit, 1));
        (comp->emit_method_table->rot_two(comp->emit));
        (comp->emit_method_table->pop_top(comp->emit));
        (comp->emit_method_table->label_assign(comp->emit, l_end));
    }
}

static void compile_star_expr(compiler_t *comp, mp_parse_node_struct_t *pns) {
    compile_syntax_error(comp, (mp_parse_node_t)pns, "*x must be assignment target");
}

static void compile_binary_op(compiler_t *comp, mp_parse_node_struct_t *pns) {
    ((void)sizeof(char[1 - 2 * !(MP_BINARY_OP_OR + PN_xor_expr - PN_expr == MP_BINARY_OP_XOR)]));
    ((void)sizeof(char[1 - 2 * !(MP_BINARY_OP_OR + PN_and_expr - PN_expr == MP_BINARY_OP_AND)]));
    mp_binary_op_t binary_op = MP_BINARY_OP_OR + ((pns)->kind_num_nodes & 0xff) - PN_expr;
    int num_nodes = ((pns)->kind_num_nodes >> 8);
    compile_node(comp, pns->nodes[0]);
    for (int i = 1; i < num_nodes; ++i) {
        compile_node(comp, pns->nodes[i]);
        (comp->emit_method_table->binary_op(comp->emit, binary_op));
    }
}

static void compile_term(compiler_t *comp, mp_parse_node_struct_t *pns) {
    int num_nodes = ((pns)->kind_num_nodes >> 8);
    compile_node(comp, pns->nodes[0]);
    for (int i = 1; i + 1 < num_nodes; i += 2) {
        compile_node(comp, pns->nodes[i + 1]);
        mp_token_kind_t tok = (((uintptr_t)(pns->nodes[i])) >> 4);
        mp_binary_op_t op = MP_BINARY_OP_LSHIFT + (tok - MP_TOKEN_OP_DBL_LESS);
        (comp->emit_method_table->binary_op(comp->emit, op));
    }
}

static void compile_factor_2(compiler_t *comp, mp_parse_node_struct_t *pns) {
    compile_node(comp, pns->nodes[1]);
    mp_token_kind_t tok = (((uintptr_t)(pns->nodes[0])) >> 4);
    mp_unary_op_t op;
    if (tok == MP_TOKEN_OP_TILDE) {
        op = MP_UNARY_OP_INVERT;
    } else {
        
# 2219 "../py/compile.c" 3
       ((
# 2219 "../py/compile.c"
       tok == MP_TOKEN_OP_PLUS || tok == MP_TOKEN_OP_MINUS
# 2219 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 2219, __func__, 
# 2219 "../py/compile.c"
       "tok == MP_TOKEN_OP_PLUS || tok == MP_TOKEN_OP_MINUS"
# 2219 "../py/compile.c" 3
       ))
# 2219 "../py/compile.c"
                                                                  ;
        op = MP_UNARY_OP_POSITIVE + (tok - MP_TOKEN_OP_PLUS);
    }
    (comp->emit_method_table->unary_op(comp->emit, op));
}

static void compile_atom_expr_normal(compiler_t *comp, mp_parse_node_struct_t *pns) {

    compile_node(comp, pns->nodes[0]);


    if (((pns->nodes[1]) == (0))) {
        return;
    }


    size_t num_trail = 1;
    mp_parse_node_struct_t **pns_trail = (mp_parse_node_struct_t**)&pns->nodes[1];
    if (((pns_trail[0])->kind_num_nodes & 0xff) == PN_atom_expr_trailers) {
        num_trail = ((pns_trail[0])->kind_num_nodes >> 8);
        pns_trail = (mp_parse_node_struct_t**)&pns_trail[0]->nodes[0];
    }


    size_t i = 0;


    if (comp->scope_cur->kind == SCOPE_FUNCTION
        && (((pns->nodes[0]) & 0x0f) == (0x02))
        && (((uintptr_t)(pns->nodes[0])) >> 4) == MP_QSTR_super
        && ((pns_trail[0])->kind_num_nodes & 0xff) == PN_trailer_paren
        && ((pns_trail[0]->nodes[0]) == (0))) {



        compile_load_id(comp, MP_QSTR___class__);


        
# 2257 "../py/compile.c" 3 4
       _Bool 
# 2257 "../py/compile.c"
            found = 
# 2257 "../py/compile.c" 3 4
                    0
# 2257 "../py/compile.c"
                         ;
        id_info_t *id = &comp->scope_cur->id_info[0];
        for (size_t n = comp->scope_cur->id_info_len; n > 0; --n, ++id) {
            if (id->flags & ID_FLAG_IS_PARAM) {

                compile_load_id(comp, id->qst);
                found = 
# 2263 "../py/compile.c" 3 4
                       1
# 2263 "../py/compile.c"
                           ;
                break;
            }
        }
        if (!found) {
            compile_syntax_error(comp, (mp_parse_node_t)pns_trail[0],
                "super() can't find self");
            return;
        }

        if (num_trail >= 3
            && ((pns_trail[1])->kind_num_nodes & 0xff) == PN_trailer_period
            && ((pns_trail[2])->kind_num_nodes & 0xff) == PN_trailer_paren) {

            mp_parse_node_struct_t *pns_period = pns_trail[1];
            mp_parse_node_struct_t *pns_paren = pns_trail[2];
            (comp->emit_method_table->load_method(comp->emit, (((uintptr_t)(pns_period->nodes[0])) >> 4), 
# 2279 "../py/compile.c" 3 4
           1
# 2279 "../py/compile.c"
           ));
            compile_trailer_paren_helper(comp, pns_paren->nodes[0], 
# 2280 "../py/compile.c" 3 4
                                                                   1
# 2280 "../py/compile.c"
                                                                       , 0);
            i = 3;
        } else {

            (comp->emit_method_table->call_function(comp->emit, 2, 0, 0));
            i = 1;
        }



    } else if ((((pns->nodes[0]) & 0x0f) == (0x02))
        && (((uintptr_t)(pns->nodes[0])) >> 4) == MP_QSTR_OrderedDict
        && ((pns_trail[0])->kind_num_nodes & 0xff) == PN_trailer_paren
        && ((pns_trail[0]->nodes[0]) != (0) && ((pns_trail[0]->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns_trail[0]->nodes[0]))->kind_num_nodes & 0xff) == (PN_atom_brace))) {


        (comp->emit_method_table->call_function(comp->emit, 0, 0, 0));
        mp_parse_node_struct_t *pns_dict = (mp_parse_node_struct_t*)pns_trail[0]->nodes[0];
        compile_atom_brace_helper(comp, pns_dict, 
# 2298 "../py/compile.c" 3 4
                                                 0
# 2298 "../py/compile.c"
                                                      );
        i = 1;

    }


    for (; i < num_trail; i++) {
        if (i + 1 < num_trail
            && ((pns_trail[i])->kind_num_nodes & 0xff) == PN_trailer_period
            && ((pns_trail[i + 1])->kind_num_nodes & 0xff) == PN_trailer_paren) {

            mp_parse_node_struct_t *pns_period = pns_trail[i];
            mp_parse_node_struct_t *pns_paren = pns_trail[i + 1];
            (comp->emit_method_table->load_method(comp->emit, (((uintptr_t)(pns_period->nodes[0])) >> 4), 
# 2311 "../py/compile.c" 3 4
           0
# 2311 "../py/compile.c"
           ));
            compile_trailer_paren_helper(comp, pns_paren->nodes[0], 
# 2312 "../py/compile.c" 3 4
                                                                   1
# 2312 "../py/compile.c"
                                                                       , 0);
            i += 1;
        } else {

            compile_node(comp, (mp_parse_node_t)pns_trail[i]);
        }
    }
}

static void compile_power(compiler_t *comp, mp_parse_node_struct_t *pns) {
    compile_generic_all_nodes(comp, pns);
    (comp->emit_method_table->binary_op(comp->emit, MP_BINARY_OP_POWER));
}

static void compile_trailer_paren_helper(compiler_t *comp, mp_parse_node_t pn_arglist, 
# 2326 "../py/compile.c" 3 4
                                                                                      _Bool 
# 2326 "../py/compile.c"
                                                                                           is_method_call, int n_positional_extra) {



    mp_parse_node_t *args;
    int n_args = mp_parse_node_extract_list(&pn_arglist, PN_arglist, &args);





    int n_positional = n_positional_extra;
    uint n_keyword = 0;
    uint star_flags = 0;
    mp_parse_node_struct_t *star_args_node = 
# 2340 "../py/compile.c" 3 4
                                            ((void *)0)
# 2340 "../py/compile.c"
                                                , *dblstar_args_node = 
# 2340 "../py/compile.c" 3 4
                                                                       ((void *)0)
# 2340 "../py/compile.c"
                                                                           ;
    for (int i = 0; i < n_args; i++) {
        if (((args[i]) != (0) && ((args[i]) & 3) == 0)) {
            mp_parse_node_struct_t *pns_arg = (mp_parse_node_struct_t*)args[i];
            if (((pns_arg)->kind_num_nodes & 0xff) == PN_arglist_star) {
                if (star_flags & (0x01)) {
                    compile_syntax_error(comp, (mp_parse_node_t)pns_arg, "can't have multiple *x");
                    return;
                }
                star_flags |= (0x01);
                star_args_node = pns_arg;
            } else if (((pns_arg)->kind_num_nodes & 0xff) == PN_arglist_dbl_star) {
                if (star_flags & (0x02)) {
                    compile_syntax_error(comp, (mp_parse_node_t)pns_arg, "can't have multiple **x");
                    return;
                }
                star_flags |= (0x02);
                dblstar_args_node = pns_arg;
            } else if (((pns_arg)->kind_num_nodes & 0xff) == PN_argument) {
                if (!((pns_arg->nodes[1]) != (0) && ((pns_arg->nodes[1]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns_arg->nodes[1]))->kind_num_nodes & 0xff) == (PN_comp_for))) {
                    if (!(((pns_arg->nodes[0]) & 0x0f) == (0x02))) {
                        compile_syntax_error(comp, (mp_parse_node_t)pns_arg, "LHS of keyword arg must be an id");
                        return;
                    }
                    (comp->emit_method_table->load_const_str(comp->emit, (((uintptr_t)(pns_arg->nodes[0])) >> 4)));
                    compile_node(comp, pns_arg->nodes[1]);
                    n_keyword += 1;
                } else {
                    compile_comprehension(comp, pns_arg, SCOPE_GEN_EXPR);
                    n_positional++;
                }
            } else {
                goto normal_argument;
            }
        } else {
            normal_argument:
            if (star_flags) {
                compile_syntax_error(comp, args[i], "non-keyword arg after */**");
                return;
            }
            if (n_keyword > 0) {
                compile_syntax_error(comp, args[i], "non-keyword arg after keyword arg");
                return;
            }
            compile_node(comp, args[i]);
            n_positional++;
        }
    }



    if (star_flags != 0) {
        if (star_args_node == 
# 2392 "../py/compile.c" 3 4
                             ((void *)0)
# 2392 "../py/compile.c"
                                 ) {
            (comp->emit_method_table->load_null(comp->emit));
        } else {
            compile_node(comp, star_args_node->nodes[0]);
        }
        if (dblstar_args_node == 
# 2397 "../py/compile.c" 3 4
                                ((void *)0)
# 2397 "../py/compile.c"
                                    ) {
            (comp->emit_method_table->load_null(comp->emit));
        } else {
            compile_node(comp, dblstar_args_node->nodes[0]);
        }
    }


    if (is_method_call) {
        (comp->emit_method_table->call_method(comp->emit, n_positional, n_keyword, star_flags));
    } else {
        (comp->emit_method_table->call_function(comp->emit, n_positional, n_keyword, star_flags));
    }
}


static void compile_comprehension(compiler_t *comp, mp_parse_node_struct_t *pns, scope_kind_t kind) {
    
# 2414 "../py/compile.c" 3
   ((
# 2414 "../py/compile.c"
   ((pns)->kind_num_nodes >> 8) == 2
# 2414 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 2414, __func__, 
# 2414 "../py/compile.c"
   "MP_PARSE_NODE_STRUCT_NUM_NODES(pns) == 2"
# 2414 "../py/compile.c" 3
   ))
# 2414 "../py/compile.c"
                                                   ;
    
# 2415 "../py/compile.c" 3
   ((
# 2415 "../py/compile.c"
   ((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[1]))->kind_num_nodes & 0xff) == (PN_comp_for))
# 2415 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 2415, __func__, 
# 2415 "../py/compile.c"
   "MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_comp_for)"
# 2415 "../py/compile.c" 3
   ))
# 2415 "../py/compile.c"
                                                                   ;
    mp_parse_node_struct_t *pns_comp_for = (mp_parse_node_struct_t*)pns->nodes[1];

    if (comp->pass == MP_PASS_SCOPE) {

        scope_t *s = scope_new_and_link(comp, kind, (mp_parse_node_t)pns, comp->scope_cur->emit_options);

        pns_comp_for->nodes[3] = (mp_parse_node_t)s;
    }


    scope_t *this_scope = (scope_t*)pns_comp_for->nodes[3];


    close_over_variables_etc(comp, this_scope, 0, 0);

    compile_node(comp, pns_comp_for->nodes[1]);
    if (kind == SCOPE_GEN_EXPR) {
        (comp->emit_method_table->get_iter(comp->emit, 
# 2433 "../py/compile.c" 3 4
       0
# 2433 "../py/compile.c"
       ));
    }
    (comp->emit_method_table->call_function(comp->emit, 1, 0, 0));
}

static void compile_atom_paren(compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (((pns->nodes[0]) == (0))) {

        c_tuple(comp, (0), 
# 2441 "../py/compile.c" 3 4
                                         ((void *)0)
# 2441 "../py/compile.c"
                                             );
    } else {
        
# 2443 "../py/compile.c" 3
       ((
# 2443 "../py/compile.c"
       ((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_testlist_comp))
# 2443 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 2443, __func__, 
# 2443 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp)"
# 2443 "../py/compile.c" 3
       ))
# 2443 "../py/compile.c"
                                                                            ;
        pns = (mp_parse_node_struct_t*)pns->nodes[0];
        
# 2445 "../py/compile.c" 3
       ((
# 2445 "../py/compile.c"
       !((pns->nodes[1]) == (0))
# 2445 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 2445, __func__, 
# 2445 "../py/compile.c"
       "!MP_PARSE_NODE_IS_NULL(pns->nodes[1])"
# 2445 "../py/compile.c" 3
       ))
# 2445 "../py/compile.c"
                                                    ;
        if (((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0)) {
            mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t*)pns->nodes[1];
            if (((pns2)->kind_num_nodes & 0xff) == PN_testlist_comp_3b) {

                
# 2450 "../py/compile.c" 3
               ((
# 2450 "../py/compile.c"
               ((pns2->nodes[0]) == (0))
# 2450 "../py/compile.c" 3
               ) ? (void)0 : __assert_func ("../py/compile.c", 2450, __func__, 
# 2450 "../py/compile.c"
               "MP_PARSE_NODE_IS_NULL(pns2->nodes[0])"
# 2450 "../py/compile.c" 3
               ))
# 2450 "../py/compile.c"
                                                            ;
                c_tuple(comp, pns->nodes[0], 
# 2451 "../py/compile.c" 3 4
                                            ((void *)0)
# 2451 "../py/compile.c"
                                                );
            } else if (((pns2)->kind_num_nodes & 0xff) == PN_testlist_comp_3c) {

                c_tuple(comp, pns->nodes[0], pns2);
            } else if (((pns2)->kind_num_nodes & 0xff) == PN_comp_for) {

                compile_comprehension(comp, pns, SCOPE_GEN_EXPR);
            } else {

                goto tuple_with_2_items;
            }
        } else {

            tuple_with_2_items:
            c_tuple(comp, (0), pns);
        }
    }
}

static void compile_atom_bracket(compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (((pns->nodes[0]) == (0))) {

        (comp->emit_method_table->build(comp->emit, 0, (1)));
    } else if (((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_testlist_comp))) {
        mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t*)pns->nodes[0];
        if (((pns2->nodes[1]) != (0) && ((pns2->nodes[1]) & 3) == 0)) {
            mp_parse_node_struct_t *pns3 = (mp_parse_node_struct_t*)pns2->nodes[1];
            if (((pns3)->kind_num_nodes & 0xff) == PN_testlist_comp_3b) {

                
# 2480 "../py/compile.c" 3
               ((
# 2480 "../py/compile.c"
               ((pns3->nodes[0]) == (0))
# 2480 "../py/compile.c" 3
               ) ? (void)0 : __assert_func ("../py/compile.c", 2480, __func__, 
# 2480 "../py/compile.c"
               "MP_PARSE_NODE_IS_NULL(pns3->nodes[0])"
# 2480 "../py/compile.c" 3
               ))
# 2480 "../py/compile.c"
                                                            ;
                compile_node(comp, pns2->nodes[0]);
                (comp->emit_method_table->build(comp->emit, 1, (1)));
            } else if (((pns3)->kind_num_nodes & 0xff) == PN_testlist_comp_3c) {

                compile_node(comp, pns2->nodes[0]);
                compile_generic_all_nodes(comp, pns3);
                (comp->emit_method_table->build(comp->emit, 1 + ((pns3)->kind_num_nodes >> 8), (1)));
            } else if (((pns3)->kind_num_nodes & 0xff) == PN_comp_for) {

                compile_comprehension(comp, pns2, SCOPE_LIST_COMP);
            } else {

                goto list_with_2_items;
            }
        } else {

            list_with_2_items:
            compile_node(comp, pns2->nodes[0]);
            compile_node(comp, pns2->nodes[1]);
            (comp->emit_method_table->build(comp->emit, 2, (1)));
        }
    } else {

        compile_node(comp, pns->nodes[0]);
        (comp->emit_method_table->build(comp->emit, 1, (1)));
    }
}

static void compile_atom_brace_helper(compiler_t *comp, mp_parse_node_struct_t *pns, 
# 2509 "../py/compile.c" 3 4
                                                                                    _Bool 
# 2509 "../py/compile.c"
                                                                                         create_map) {
    mp_parse_node_t pn = pns->nodes[0];
    if (((pn) == (0))) {

        if (create_map) {
            (comp->emit_method_table->build(comp->emit, 0, (2)));
        }
    } else if (((pn) != (0) && ((pn) & 3) == 0)) {
        pns = (mp_parse_node_struct_t*)pn;
        if (((pns)->kind_num_nodes & 0xff) == PN_dictorsetmaker_item) {

            if (create_map) {
                (comp->emit_method_table->build(comp->emit, 1, (2)));
            }
            compile_node(comp, pn);
            (comp->emit_method_table->store_map(comp->emit));
        } else if (((pns)->kind_num_nodes & 0xff) == PN_dictorsetmaker) {
            
# 2526 "../py/compile.c" 3
           ((
# 2526 "../py/compile.c"
           ((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0)
# 2526 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 2526, __func__, 
# 2526 "../py/compile.c"
           "MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])"
# 2526 "../py/compile.c" 3
           ))
# 2526 "../py/compile.c"
                                                         ;
            mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t*)pns->nodes[1];
            if (((pns1)->kind_num_nodes & 0xff) == PN_dictorsetmaker_list) {



                mp_parse_node_t *nodes;
                int n = mp_parse_node_extract_list(&pns1->nodes[0], PN_dictorsetmaker_list2, &nodes);


                
# 2536 "../py/compile.c" 3 4
               _Bool 
# 2536 "../py/compile.c"
                    is_dict;
                if (!(1) || ((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_dictorsetmaker_item))) {

                    if (create_map) {
                        (comp->emit_method_table->build(comp->emit, 1 + n, (2)));
                    }
                    compile_node(comp, pns->nodes[0]);
                    (comp->emit_method_table->store_map(comp->emit));
                    is_dict = 
# 2544 "../py/compile.c" 3 4
                             1
# 2544 "../py/compile.c"
                                 ;
                } else {

                    compile_node(comp, pns->nodes[0]);
                    is_dict = 
# 2548 "../py/compile.c" 3 4
                             0
# 2548 "../py/compile.c"
                                  ;
                }


                for (int i = 0; i < n; i++) {
                    mp_parse_node_t pn_i = nodes[i];
                    
# 2554 "../py/compile.c" 3 4
                   _Bool 
# 2554 "../py/compile.c"
                        is_key_value = ((pn_i) != (0) && ((pn_i) & 3) == 0 && (((mp_parse_node_struct_t*)(pn_i))->kind_num_nodes & 0xff) == (PN_dictorsetmaker_item));
                    compile_node(comp, pn_i);
                    if (is_dict) {
                        if (!is_key_value) {
                            if (((3)) == (1)) {
                                compile_syntax_error(comp, (mp_parse_node_t)pns, "invalid syntax");
                            } else {
                                compile_syntax_error(comp, (mp_parse_node_t)pns, "expecting key:value for dict");
                            }
                            return;
                        }
                        (comp->emit_method_table->store_map(comp->emit));
                    } else {
                        if (is_key_value) {
                            if (((3)) == (1)) {
                                compile_syntax_error(comp, (mp_parse_node_t)pns, "invalid syntax");
                            } else {
                                compile_syntax_error(comp, (mp_parse_node_t)pns, "expecting just a value for set");
                            }
                            return;
                        }
                    }
                }



                if (!is_dict) {
                    (comp->emit_method_table->build(comp->emit, 1 + n, (3)));
                }

            } else {
                
# 2585 "../py/compile.c" 3
               ((
# 2585 "../py/compile.c"
               ((pns1)->kind_num_nodes & 0xff) == PN_comp_for
# 2585 "../py/compile.c" 3
               ) ? (void)0 : __assert_func ("../py/compile.c", 2585, __func__, 
# 2585 "../py/compile.c"
               "MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_comp_for"
# 2585 "../py/compile.c" 3
               ))
# 2585 "../py/compile.c"
                                                                     ;

                if (!(1) || ((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_dictorsetmaker_item))) {

                    compile_comprehension(comp, pns, SCOPE_DICT_COMP);
                } else {

                    compile_comprehension(comp, pns, SCOPE_SET_COMP);
                }
            }
        } else {

            goto set_with_one_element;
        }
    } else {

        set_with_one_element:

        compile_node(comp, pn);
        (comp->emit_method_table->build(comp->emit, 1, (3)));



    }
}

static void compile_atom_brace(compiler_t *comp, mp_parse_node_struct_t *pns) {
    compile_atom_brace_helper(comp, pns, 
# 2612 "../py/compile.c" 3 4
                                        1
# 2612 "../py/compile.c"
                                            );
}

static void compile_trailer_paren(compiler_t *comp, mp_parse_node_struct_t *pns) {
    compile_trailer_paren_helper(comp, pns->nodes[0], 
# 2616 "../py/compile.c" 3 4
                                                     0
# 2616 "../py/compile.c"
                                                          , 0);
}

static void compile_trailer_bracket(compiler_t *comp, mp_parse_node_struct_t *pns) {

    compile_node(comp, pns->nodes[0]);
    (comp->emit_method_table->subscr(comp->emit, (0)));
}

static void compile_trailer_period(compiler_t *comp, mp_parse_node_struct_t *pns) {

    (comp->emit_method_table->attr(comp->emit, (((uintptr_t)(pns->nodes[0])) >> 4), (0)));
}


static void compile_subscript(compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (((pns)->kind_num_nodes & 0xff) == PN_subscript_2) {
        compile_node(comp, pns->nodes[0]);
        
# 2634 "../py/compile.c" 3
       ((
# 2634 "../py/compile.c"
       ((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0)
# 2634 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 2634, __func__, 
# 2634 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])"
# 2634 "../py/compile.c" 3
       ))
# 2634 "../py/compile.c"
                                                     ;
        pns = (mp_parse_node_struct_t*)pns->nodes[1];
    } else {

        (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
    }

    
# 2641 "../py/compile.c" 3
   ((
# 2641 "../py/compile.c"
   ((pns)->kind_num_nodes & 0xff) == PN_subscript_3
# 2641 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 2641, __func__, 
# 2641 "../py/compile.c"
   "MP_PARSE_NODE_STRUCT_KIND(pns) == PN_subscript_3"
# 2641 "../py/compile.c" 3
   ))
# 2641 "../py/compile.c"
                                                           ;
    mp_parse_node_t pn = pns->nodes[0];
    if (((pn) == (0))) {

        (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
        (comp->emit_method_table->build(comp->emit, 2, (4)));
    } else if (((pn) != (0) && ((pn) & 3) == 0)) {
        pns = (mp_parse_node_struct_t*)pn;
        if (((pns)->kind_num_nodes & 0xff) == PN_subscript_3c) {
            (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
            pn = pns->nodes[0];
            if (((pn) == (0))) {

                (comp->emit_method_table->build(comp->emit, 2, (4)));
            } else {

                compile_node(comp, pn);
                (comp->emit_method_table->build(comp->emit, 3, (4)));
            }
        } else if (((pns)->kind_num_nodes & 0xff) == PN_subscript_3d) {
            compile_node(comp, pns->nodes[0]);
            
# 2662 "../py/compile.c" 3
           ((
# 2662 "../py/compile.c"
           ((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0)
# 2662 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 2662, __func__, 
# 2662 "../py/compile.c"
           "MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])"
# 2662 "../py/compile.c" 3
           ))
# 2662 "../py/compile.c"
                                                         ;
            pns = (mp_parse_node_struct_t*)pns->nodes[1];
            
# 2664 "../py/compile.c" 3
           ((
# 2664 "../py/compile.c"
           ((pns)->kind_num_nodes & 0xff) == PN_sliceop
# 2664 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 2664, __func__, 
# 2664 "../py/compile.c"
           "MP_PARSE_NODE_STRUCT_KIND(pns) == PN_sliceop"
# 2664 "../py/compile.c" 3
           ))
# 2664 "../py/compile.c"
                                                               ;
            if (((pns->nodes[0]) == (0))) {

                (comp->emit_method_table->build(comp->emit, 2, (4)));
            } else {

                compile_node(comp, pns->nodes[0]);
                (comp->emit_method_table->build(comp->emit, 3, (4)));
            }
        } else {

            compile_node(comp, pn);
            (comp->emit_method_table->build(comp->emit, 2, (4)));
        }
    } else {

        compile_node(comp, pn);
        (comp->emit_method_table->build(comp->emit, 2, (4)));
    }
}


static void compile_dictorsetmaker_item(compiler_t *comp, mp_parse_node_struct_t *pns) {

    compile_node(comp, pns->nodes[1]);
    compile_node(comp, pns->nodes[0]);
}

static void compile_classdef(compiler_t *comp, mp_parse_node_struct_t *pns) {
    qstr cname = compile_classdef_helper(comp, pns, comp->scope_cur->emit_options);

    compile_store_id(comp, cname);
}

static void compile_yield_expr(compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->scope_cur->kind != SCOPE_FUNCTION && comp->scope_cur->kind != SCOPE_LAMBDA) {
        compile_syntax_error(comp, (mp_parse_node_t)pns, "'yield' outside function");
        return;
    }
    if (((pns->nodes[0]) == (0))) {
        (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
        (comp->emit_method_table->yield(comp->emit, (0)));
        reserve_labels_for_native(comp, 1);
    } else if (((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_yield_arg_from))) {
        pns = (mp_parse_node_struct_t*)pns->nodes[0];
        compile_node(comp, pns->nodes[0]);
        compile_yield_from(comp);
    } else {
        compile_node(comp, pns->nodes[0]);
        (comp->emit_method_table->yield(comp->emit, (0)));
        reserve_labels_for_native(comp, 1);
    }
}


static void compile_atom_expr_await(compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->scope_cur->kind != SCOPE_FUNCTION && comp->scope_cur->kind != SCOPE_LAMBDA) {
        compile_syntax_error(comp, (mp_parse_node_t)pns, "'await' outside function");
        return;
    }
    compile_atom_expr_normal(comp, pns);
    compile_yield_from(comp);
}


static mp_obj_t get_const_object(mp_parse_node_struct_t *pns) {




    return (mp_obj_t)pns->nodes[0];

}

static void compile_const_object(compiler_t *comp, mp_parse_node_struct_t *pns) {
    (comp->emit_method_table->load_const_obj(comp->emit, get_const_object(pns)));
}

typedef void (*compile_function_t)(compiler_t*, mp_parse_node_struct_t*);
static const compile_function_t compile_function[] = {




# 1 "../py/grammar.h" 1
# 40 "../py/grammar.h"

compile_generic_all_nodes,
compile_generic_all_nodes,



# 58 "../py/grammar.h"


compile_decorated,






compile_funcdef,


























compile_generic_all_nodes,








compile_expr_stmt,





compile_generic_tuple,


# 122 "../py/grammar.h"
compile_del_stmt,
compile_generic_all_nodes,

compile_break_cont_stmt,
compile_break_cont_stmt,
compile_return_stmt,
compile_yield_stmt,
compile_raise_stmt,


# 145 "../py/grammar.h"

compile_import_name,
compile_import_from,












compile_global_nonlocal_stmt,
compile_global_nonlocal_stmt,

compile_assert_stmt,

# 179 "../py/grammar.h"

compile_async_stmt,




compile_if_stmt,


compile_while_stmt,
compile_for_stmt,
compile_try_stmt,







compile_with_stmt,





compile_generic_all_nodes,







compile_test_if_expr,


compile_lambdef,
compile_lambdef,
# 234 "../py/grammar.h"
compile_or_and_test,
compile_or_and_test,

compile_not_test_2,
compile_comparison,




compile_star_expr,
compile_binary_op,
compile_binary_op,
compile_binary_op,
compile_term,

compile_term,

compile_term,


compile_factor_2,

compile_power,


compile_atom_expr_await,



compile_atom_expr_normal,








compile_atom_paren,

compile_atom_bracket,
compile_atom_brace,






compile_trailer_paren,
compile_trailer_bracket,
compile_trailer_period,






compile_generic_tuple,

compile_subscript,
compile_subscript,




# 307 "../py/grammar.h"


compile_generic_tuple,



compile_dictorsetmaker_item,










compile_classdef,









# 342 "../py/grammar.h"













compile_yield_expr,


# 2749 "../py/compile.c" 2



    compile_const_object,
};

static void compile_node(compiler_t *comp, mp_parse_node_t pn) {
    if (((pn) == (0))) {

    } else if ((((pn) & 0x1) == (0x1))) {
        mp_int_t arg = (((mp_int_t)(intptr_t)(pn)) >> 1);
# 2775 "../py/compile.c"
        (comp->emit_method_table->load_const_small_int(comp->emit, arg));

    } else if (((pn) & 3)) {
        uintptr_t arg = (((uintptr_t)(pn)) >> 4);
        switch (((pn) & 0x0f)) {
            case (0x02): compile_load_id(comp, arg); break;
            case (0x06): (comp->emit_method_table->load_const_str(comp->emit, arg)); break;
            case (0x0a):

                if (comp->pass != MP_PASS_EMIT) {
                    (comp->emit_method_table->load_const_obj(comp->emit, (((mp_obj_t)&mp_const_none_obj))));
                } else {
                    size_t len;
                    const byte *data = qstr_data(arg, &len);
                    (comp->emit_method_table->load_const_obj(comp->emit, mp_obj_new_bytes(data, len)));
                }
                break;
            case (0x0e): default:
                if (arg == MP_TOKEN_NEWLINE) {



                } else {
                  (comp->emit_method_table->load_const_tok(comp->emit, arg));
                }
                break;
        }
    } else {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        (comp->emit_method_table->set_source_line(comp->emit, pns->source_line));
        
# 2805 "../py/compile.c" 3
       ((
# 2805 "../py/compile.c"
       ((pns)->kind_num_nodes & 0xff) <= PN_const_object
# 2805 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 2805, __func__, 
# 2805 "../py/compile.c"
       "MP_PARSE_NODE_STRUCT_KIND(pns) <= PN_const_object"
# 2805 "../py/compile.c" 3
       ))
# 2805 "../py/compile.c"
                                                                ;
        compile_function_t f = compile_function[((pns)->kind_num_nodes & 0xff)];
        f(comp, pns);
    }
}


static int compile_viper_type_annotation(compiler_t *comp, mp_parse_node_t pn_annotation) {
    int native_type = (0x00);
    if (((pn_annotation) == (0))) {

    } else if ((((pn_annotation) & 0x0f) == (0x02))) {
        qstr type_name = (((uintptr_t)(pn_annotation)) >> 4);
        native_type = mp_native_type_from_qstr(type_name);
        if (native_type < 0) {
            comp->compile_error = mp_obj_new_exception_msg_varg(&mp_type_ViperTypeError, "unknown type '%q'", type_name);
            native_type = 0;
        }
    } else {
        compile_syntax_error(comp, pn_annotation, "annotation must be an identifier");
    }
    return native_type;
}


static void compile_scope_func_lambda_param(compiler_t *comp, mp_parse_node_t pn, pn_kind_t pn_name, pn_kind_t pn_star, pn_kind_t pn_dbl_star) {
    (void)pn_dbl_star;


    if ((comp->scope_cur->scope_flags & (0x02)) != 0) {
        compile_syntax_error(comp, pn, "invalid syntax");
        return;
    }

    qstr param_name = MP_QSTRnull;
    uint param_flag = ID_FLAG_IS_PARAM;
    mp_parse_node_struct_t *pns = 
# 2841 "../py/compile.c" 3 4
                                 ((void *)0)
# 2841 "../py/compile.c"
                                     ;
    if ((((pn) & 0x0f) == (0x02))) {
        param_name = (((uintptr_t)(pn)) >> 4);
        if (comp->have_star) {

            comp->scope_cur->num_kwonly_args += 1;
        } else {

            comp->scope_cur->num_pos_args += 1;
        }
    } else {
        
# 2852 "../py/compile.c" 3
       ((
# 2852 "../py/compile.c"
       ((pn) != (0) && ((pn) & 3) == 0)
# 2852 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 2852, __func__, 
# 2852 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT(pn)"
# 2852 "../py/compile.c" 3
       ))
# 2852 "../py/compile.c"
                                          ;
        pns = (mp_parse_node_struct_t*)pn;
        if (((pns)->kind_num_nodes & 0xff) == pn_name) {

            param_name = (((uintptr_t)(pns->nodes[0])) >> 4);
            if (comp->have_star) {

                comp->scope_cur->num_kwonly_args += 1;
            } else {

                comp->scope_cur->num_pos_args += 1;
            }
        } else if (((pns)->kind_num_nodes & 0xff) == pn_star) {
            if (comp->have_star) {

                compile_syntax_error(comp, pn, "invalid syntax");
                return;
            }
            comp->have_star = 
# 2870 "../py/compile.c" 3 4
                             1
# 2870 "../py/compile.c"
                                 ;
            param_flag = ID_FLAG_IS_PARAM | ID_FLAG_IS_STAR_PARAM;
            if (((pns->nodes[0]) == (0))) {



                pns = 
# 2876 "../py/compile.c" 3 4
                     ((void *)0)
# 2876 "../py/compile.c"
                         ;
            } else if ((((pns->nodes[0]) & 0x0f) == (0x02))) {

                comp->scope_cur->scope_flags |= (0x04);
                param_name = (((uintptr_t)(pns->nodes[0])) >> 4);
                pns = 
# 2881 "../py/compile.c" 3 4
                     ((void *)0)
# 2881 "../py/compile.c"
                         ;
            } else {
                
# 2883 "../py/compile.c" 3
               ((
# 2883 "../py/compile.c"
               ((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_tfpdef))
# 2883 "../py/compile.c" 3
               ) ? (void)0 : __assert_func ("../py/compile.c", 2883, __func__, 
# 2883 "../py/compile.c"
               "MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_tfpdef)"
# 2883 "../py/compile.c" 3
               ))
# 2883 "../py/compile.c"
                                                                             ;

                comp->scope_cur->scope_flags |= (0x04);
                pns = (mp_parse_node_struct_t*)pns->nodes[0];
                param_name = (((uintptr_t)(pns->nodes[0])) >> 4);
            }
        } else {

            
# 2891 "../py/compile.c" 3
           ((
# 2891 "../py/compile.c"
           ((pns)->kind_num_nodes & 0xff) == pn_dbl_star
# 2891 "../py/compile.c" 3
           ) ? (void)0 : __assert_func ("../py/compile.c", 2891, __func__, 
# 2891 "../py/compile.c"
           "MP_PARSE_NODE_STRUCT_KIND(pns) == pn_dbl_star"
# 2891 "../py/compile.c" 3
           ))
# 2891 "../py/compile.c"
                                                                ;
            param_name = (((uintptr_t)(pns->nodes[0])) >> 4);
            param_flag = ID_FLAG_IS_PARAM | ID_FLAG_IS_DBL_STAR_PARAM;
            comp->scope_cur->scope_flags |= (0x02);
        }
    }

    if (param_name != MP_QSTRnull) {
        id_info_t *id_info = scope_find_or_add_id(comp->scope_cur, param_name, ID_INFO_KIND_UNDECIDED);
        if (id_info->kind != ID_INFO_KIND_UNDECIDED) {
            compile_syntax_error(comp, pn, "argument name reused");
            return;
        }
        id_info->kind = ID_INFO_KIND_LOCAL;
        id_info->flags = param_flag;


        if (comp->scope_cur->emit_options == MP_EMIT_OPT_VIPER && pn_name == PN_typedargslist_name && pns != 
# 2908 "../py/compile.c" 3 4
                                                                                                            ((void *)0)
# 2908 "../py/compile.c"
                                                                                                                ) {
            id_info->flags |= compile_viper_type_annotation(comp, pns->nodes[1]) << ID_FLAG_VIPER_TYPE_POS;
        }



    }
}

static void compile_scope_func_param(compiler_t *comp, mp_parse_node_t pn) {
    compile_scope_func_lambda_param(comp, pn, PN_typedargslist_name, PN_typedargslist_star, PN_typedargslist_dbl_star);
}

static void compile_scope_lambda_param(compiler_t *comp, mp_parse_node_t pn) {
    compile_scope_func_lambda_param(comp, pn, PN_varargslist_name, PN_varargslist_star, PN_varargslist_dbl_star);
}

static void compile_scope_comp_iter(compiler_t *comp, mp_parse_node_struct_t *pns_comp_for, mp_parse_node_t pn_inner_expr, int for_depth) {
    uint l_top = comp_next_label(comp);
    uint l_end = comp_next_label(comp);
    (comp->emit_method_table->label_assign(comp->emit, l_top));
    (comp->emit_method_table->for_iter(comp->emit, l_end));
    c_assign(comp, pns_comp_for->nodes[0], ASSIGN_STORE);
    mp_parse_node_t pn_iter = pns_comp_for->nodes[2];

    tail_recursion:
    if (((pn_iter) == (0))) {

        compile_node(comp, pn_inner_expr);
        if (comp->scope_cur->kind == SCOPE_GEN_EXPR) {
            (comp->emit_method_table->yield(comp->emit, (0)));
            reserve_labels_for_native(comp, 1);
            (comp->emit_method_table->pop_top(comp->emit));
        } else {
            (comp->emit_method_table->store_comp(comp->emit, comp->scope_cur->kind, 4 * for_depth + 5));
        }
    } else if ((((mp_parse_node_struct_t*)pn_iter)->kind_num_nodes & 0xff) == PN_comp_if) {

        mp_parse_node_struct_t *pns_comp_if = (mp_parse_node_struct_t*)pn_iter;
        c_if_cond(comp, pns_comp_if->nodes[0], 
# 2947 "../py/compile.c" 3 4
                                              0
# 2947 "../py/compile.c"
                                                   , l_top);
        pn_iter = pns_comp_if->nodes[1];
        goto tail_recursion;
    } else {
        
# 2951 "../py/compile.c" 3
       ((
# 2951 "../py/compile.c"
       (((mp_parse_node_struct_t*)pn_iter)->kind_num_nodes & 0xff) == PN_comp_for
# 2951 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 2951, __func__, 
# 2951 "../py/compile.c"
       "MP_PARSE_NODE_STRUCT_KIND((mp_parse_node_struct_t*)pn_iter) == PN_comp_for"
# 2951 "../py/compile.c" 3
       ))
# 2951 "../py/compile.c"
                                                                                         ;

        mp_parse_node_struct_t *pns_comp_for2 = (mp_parse_node_struct_t*)pn_iter;
        compile_node(comp, pns_comp_for2->nodes[1]);
        (comp->emit_method_table->get_iter(comp->emit, 
# 2955 "../py/compile.c" 3 4
       1
# 2955 "../py/compile.c"
       ));
        compile_scope_comp_iter(comp, pns_comp_for2, pn_inner_expr, for_depth + 1);
    }

    (comp->emit_method_table->jump(comp->emit, l_top));
    (comp->emit_method_table->label_assign(comp->emit, l_end));
    (comp->emit_method_table->for_iter_end(comp->emit));
}

static void check_for_doc_string(compiler_t *comp, mp_parse_node_t pn) {




    if (((pn) != (0) && ((pn) & 3) == 0 && (((mp_parse_node_struct_t*)(pn))->kind_num_nodes & 0xff) == (PN_expr_stmt))) {

    } else if (((pn) != (0) && ((pn) & 3) == 0 && (((mp_parse_node_struct_t*)(pn))->kind_num_nodes & 0xff) == (PN_file_input_2))) {

        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        int num_nodes = ((pns)->kind_num_nodes >> 8);
        for (int i = 0; i < num_nodes; i++) {
            pn = pns->nodes[i];
            if (!(((pn) & 3) && ((pn) & 0x0f) == (0x0e) && (((uintptr_t)(pn)) >> 4) == MP_TOKEN_NEWLINE)) {

                break;
            }
        }

    } else if (((pn) != (0) && ((pn) & 3) == 0 && (((mp_parse_node_struct_t*)(pn))->kind_num_nodes & 0xff) == (PN_suite_block_stmts))) {

        pn = ((mp_parse_node_struct_t*)pn)->nodes[0];
    } else {
        return;
    }


    if (((pn) != (0) && ((pn) & 3) == 0 && (((mp_parse_node_struct_t*)(pn))->kind_num_nodes & 0xff) == (PN_expr_stmt))) {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        if ((((pns->nodes[0]) & 3)
                && ((pns->nodes[0]) & 0x0f) == (0x06))
            || (((pns->nodes[0]) != (0) && ((pns->nodes[0]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[0]))->kind_num_nodes & 0xff) == (PN_const_object))
                && (mp_obj_is_qstr(get_const_object((mp_parse_node_struct_t*)pns->nodes[0])) || (mp_obj_is_obj(get_const_object((mp_parse_node_struct_t*)pns->nodes[0])) && (((mp_obj_base_t*)((void*)get_const_object((mp_parse_node_struct_t*)pns->nodes[0])))->type == (&mp_type_str)))))) {

                compile_node(comp, pns->nodes[0]);

                compile_store_id(comp, MP_QSTR___doc__);
        }
    }




}

static void compile_scope(compiler_t *comp, scope_t *scope, pass_kind_t pass) {
    comp->pass = pass;
    comp->scope_cur = scope;
    comp->next_label = 0;
    (comp->emit_method_table->start_pass(comp->emit, pass, scope));
    reserve_labels_for_native(comp, 6);

    if (comp->pass == MP_PASS_SCOPE) {


        scope->stack_size = 0;
        scope->exc_stack_size = 0;
    }


    if (((scope->pn) != (0) && ((scope->pn) & 3) == 0 && (((mp_parse_node_struct_t*)(scope->pn))->kind_num_nodes & 0xff) == (PN_eval_input))) {
        
# 3025 "../py/compile.c" 3
       ((
# 3025 "../py/compile.c"
       scope->kind == SCOPE_MODULE
# 3025 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 3025, __func__, 
# 3025 "../py/compile.c"
       "scope->kind == SCOPE_MODULE"
# 3025 "../py/compile.c" 3
       ))
# 3025 "../py/compile.c"
                                          ;
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)scope->pn;
        compile_node(comp, pns->nodes[0]);
        (comp->emit_method_table->return_value(comp->emit));
    } else if (scope->kind == SCOPE_MODULE) {
        if (!comp->is_repl) {
            check_for_doc_string(comp, scope->pn);
        }
        compile_node(comp, scope->pn);
        (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
        (comp->emit_method_table->return_value(comp->emit));
    } else if (scope->kind == SCOPE_FUNCTION) {
        
# 3037 "../py/compile.c" 3
       ((
# 3037 "../py/compile.c"
       ((scope->pn) != (0) && ((scope->pn) & 3) == 0)
# 3037 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 3037, __func__, 
# 3037 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT(scope->pn)"
# 3037 "../py/compile.c" 3
       ))
# 3037 "../py/compile.c"
                                                 ;
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)scope->pn;
        
# 3039 "../py/compile.c" 3
       ((
# 3039 "../py/compile.c"
       ((pns)->kind_num_nodes & 0xff) == PN_funcdef
# 3039 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 3039, __func__, 
# 3039 "../py/compile.c"
       "MP_PARSE_NODE_STRUCT_KIND(pns) == PN_funcdef"
# 3039 "../py/compile.c" 3
       ))
# 3039 "../py/compile.c"
                                                           ;



        if (comp->pass == MP_PASS_SCOPE) {
            comp->have_star = 
# 3044 "../py/compile.c" 3 4
                             0
# 3044 "../py/compile.c"
                                  ;
            apply_to_single_or_list(comp, pns->nodes[1], PN_typedargslist, compile_scope_func_param);


            if (scope->emit_options == MP_EMIT_OPT_VIPER) {

                scope->scope_flags |= compile_viper_type_annotation(comp, pns->nodes[2]) << (6);
            }

        }

        compile_node(comp, pns->nodes[3]);

        if (!(comp->emit_method_table->last_emit_was_return_value(comp->emit))) {
            (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
            (comp->emit_method_table->return_value(comp->emit));
        }
    } else if (scope->kind == SCOPE_LAMBDA) {
        
# 3062 "../py/compile.c" 3
       ((
# 3062 "../py/compile.c"
       ((scope->pn) != (0) && ((scope->pn) & 3) == 0)
# 3062 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 3062, __func__, 
# 3062 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT(scope->pn)"
# 3062 "../py/compile.c" 3
       ))
# 3062 "../py/compile.c"
                                                 ;
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)scope->pn;
        
# 3064 "../py/compile.c" 3
       ((
# 3064 "../py/compile.c"
       ((pns)->kind_num_nodes >> 8) == 3
# 3064 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 3064, __func__, 
# 3064 "../py/compile.c"
       "MP_PARSE_NODE_STRUCT_NUM_NODES(pns) == 3"
# 3064 "../py/compile.c" 3
       ))
# 3064 "../py/compile.c"
                                                       ;


        (comp->emit_method_table->set_source_line(comp->emit, pns->source_line));



        if (comp->pass == MP_PASS_SCOPE) {
            comp->have_star = 
# 3072 "../py/compile.c" 3 4
                             0
# 3072 "../py/compile.c"
                                  ;
            apply_to_single_or_list(comp, pns->nodes[0], PN_varargslist, compile_scope_lambda_param);
        }

        compile_node(comp, pns->nodes[1]);


        if (scope->scope_flags & (0x01)) {
            (comp->emit_method_table->pop_top(comp->emit));
            (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
        }
        (comp->emit_method_table->return_value(comp->emit));
    } else if (scope->kind == SCOPE_LIST_COMP || scope->kind == SCOPE_DICT_COMP || scope->kind == SCOPE_SET_COMP || scope->kind == SCOPE_GEN_EXPR) {


        
# 3087 "../py/compile.c" 3
       ((
# 3087 "../py/compile.c"
       ((scope->pn) != (0) && ((scope->pn) & 3) == 0)
# 3087 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 3087, __func__, 
# 3087 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT(scope->pn)"
# 3087 "../py/compile.c" 3
       ))
# 3087 "../py/compile.c"
                                                 ;
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)scope->pn;
        
# 3089 "../py/compile.c" 3
       ((
# 3089 "../py/compile.c"
       ((pns)->kind_num_nodes >> 8) == 2
# 3089 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 3089, __func__, 
# 3089 "../py/compile.c"
       "MP_PARSE_NODE_STRUCT_NUM_NODES(pns) == 2"
# 3089 "../py/compile.c" 3
       ))
# 3089 "../py/compile.c"
                                                       ;
        
# 3090 "../py/compile.c" 3
       ((
# 3090 "../py/compile.c"
       ((pns->nodes[1]) != (0) && ((pns->nodes[1]) & 3) == 0 && (((mp_parse_node_struct_t*)(pns->nodes[1]))->kind_num_nodes & 0xff) == (PN_comp_for))
# 3090 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 3090, __func__, 
# 3090 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_comp_for)"
# 3090 "../py/compile.c" 3
       ))
# 3090 "../py/compile.c"
                                                                       ;
        mp_parse_node_struct_t *pns_comp_for = (mp_parse_node_struct_t*)pns->nodes[1];





        qstr qstr_arg = MP_QSTR_;
        if (comp->pass == MP_PASS_SCOPE) {
            scope_find_or_add_id(comp->scope_cur, qstr_arg, ID_INFO_KIND_LOCAL);
            scope->num_pos_args = 1;
        }


        (comp->emit_method_table->set_source_line(comp->emit, pns->source_line));

        if (scope->kind == SCOPE_LIST_COMP) {
            (comp->emit_method_table->build(comp->emit, 0, (1)));
        } else if (scope->kind == SCOPE_DICT_COMP) {
            (comp->emit_method_table->build(comp->emit, 0, (2)));

        } else if (scope->kind == SCOPE_SET_COMP) {
            (comp->emit_method_table->build(comp->emit, 0, (3)));

        }



        if (scope->kind == SCOPE_GEN_EXPR) {
            ((void)sizeof(char[1 - 2 * !(((sizeof(mp_obj_iter_buf_t) + sizeof(mp_obj_t) - 1) / sizeof(mp_obj_t)) == 4)]));
            (comp->emit_method_table->load_null(comp->emit));
            compile_load_id(comp, qstr_arg);
            (comp->emit_method_table->load_null(comp->emit));
            (comp->emit_method_table->load_null(comp->emit));
        } else {
            compile_load_id(comp, qstr_arg);
            (comp->emit_method_table->get_iter(comp->emit, 
# 3126 "../py/compile.c" 3 4
           1
# 3126 "../py/compile.c"
           ));
        }

        compile_scope_comp_iter(comp, pns_comp_for, pns->nodes[0], 0);

        if (scope->kind == SCOPE_GEN_EXPR) {
            (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
        }
        (comp->emit_method_table->return_value(comp->emit));
    } else {
        
# 3136 "../py/compile.c" 3
       ((
# 3136 "../py/compile.c"
       scope->kind == SCOPE_CLASS
# 3136 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 3136, __func__, 
# 3136 "../py/compile.c"
       "scope->kind == SCOPE_CLASS"
# 3136 "../py/compile.c" 3
       ))
# 3136 "../py/compile.c"
                                         ;
        
# 3137 "../py/compile.c" 3
       ((
# 3137 "../py/compile.c"
       ((scope->pn) != (0) && ((scope->pn) & 3) == 0)
# 3137 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 3137, __func__, 
# 3137 "../py/compile.c"
       "MP_PARSE_NODE_IS_STRUCT(scope->pn)"
# 3137 "../py/compile.c" 3
       ))
# 3137 "../py/compile.c"
                                                 ;
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)scope->pn;
        
# 3139 "../py/compile.c" 3
       ((
# 3139 "../py/compile.c"
       ((pns)->kind_num_nodes & 0xff) == PN_classdef
# 3139 "../py/compile.c" 3
       ) ? (void)0 : __assert_func ("../py/compile.c", 3139, __func__, 
# 3139 "../py/compile.c"
       "MP_PARSE_NODE_STRUCT_KIND(pns) == PN_classdef"
# 3139 "../py/compile.c" 3
       ))
# 3139 "../py/compile.c"
                                                            ;

        if (comp->pass == MP_PASS_SCOPE) {
            scope_find_or_add_id(scope, MP_QSTR___class__, ID_INFO_KIND_LOCAL);
        }




        compile_load_id(comp, MP_QSTR___name__);
        compile_store_id(comp, MP_QSTR___module__);
        (comp->emit_method_table->load_const_str(comp->emit, (((uintptr_t)(pns->nodes[0])) >> 4)));
        compile_store_id(comp, MP_QSTR___qualname__);

        check_for_doc_string(comp, pns->nodes[2]);
        compile_node(comp, pns->nodes[2]);

        id_info_t *id = scope_find(scope, MP_QSTR___class__);
        
# 3157 "../py/compile.c" 3
       ((
# 3157 "../py/compile.c"
       id != 
# 3157 "../py/compile.c" 3 4
       ((void *)0)) ? (void)0 : __assert_func ("../py/compile.c", 3157, __func__, 
# 3157 "../py/compile.c"
       "id != NULL"
# 3157 "../py/compile.c" 3
       ))
# 3157 "../py/compile.c"
                         ;
        if (id->kind == ID_INFO_KIND_LOCAL) {
            (comp->emit_method_table->load_const_tok(comp->emit, MP_TOKEN_KW_NONE));
        } else {
            (comp->emit_method_table->load_id.local(comp->emit, MP_QSTR___class__, id->local_num, (0)));
        }
        (comp->emit_method_table->return_value(comp->emit));
    }

    (comp->emit_method_table->end_pass(comp->emit));


    
# 3169 "../py/compile.c" 3
   ((
# 3169 "../py/compile.c"
   comp->cur_except_level == 0
# 3169 "../py/compile.c" 3
   ) ? (void)0 : __assert_func ("../py/compile.c", 3169, __func__, 
# 3169 "../py/compile.c"
   "comp->cur_except_level == 0"
# 3169 "../py/compile.c" 3
   ))
# 3169 "../py/compile.c"
                                      ;
}
# 3337 "../py/compile.c"
static void scope_compute_things(scope_t *scope) {

    if (scope->scope_flags & (0x04)) {
        id_info_t *id_param = 
# 3340 "../py/compile.c" 3 4
                             ((void *)0)
# 3340 "../py/compile.c"
                                 ;
        for (int i = scope->id_info_len - 1; i >= 0; i--) {
            id_info_t *id = &scope->id_info[i];
            if (id->flags & ID_FLAG_IS_STAR_PARAM) {
                if (id_param != 
# 3344 "../py/compile.c" 3 4
                               ((void *)0)
# 3344 "../py/compile.c"
                                   ) {

                    id_info_t temp = *id_param; *id_param = *id; *id = temp;
                }
                break;
            } else if (id_param == 
# 3349 "../py/compile.c" 3 4
                                  ((void *)0) 
# 3349 "../py/compile.c"
                                       && id->flags == ID_FLAG_IS_PARAM) {
                id_param = id;
            }
        }
    }



    scope->num_locals = 0;
    for (int i = 0; i < scope->id_info_len; i++) {
        id_info_t *id = &scope->id_info[i];
        if (scope->kind == SCOPE_CLASS && id->qst == MP_QSTR___class__) {

            continue;
        }
        if (((scope->kind) >= SCOPE_LAMBDA) && id->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {
            id->kind = ID_INFO_KIND_GLOBAL_EXPLICIT;
        }

        if (id->kind == ID_INFO_KIND_GLOBAL_EXPLICIT) {

            if (scope->emit_options == MP_EMIT_OPT_VIPER
                && mp_native_type_from_qstr(id->qst) >= (0x02)) {

            } else {
                scope->scope_flags |= (0x10);
            }
        }


        if (id->kind == ID_INFO_KIND_LOCAL || (id->flags & ID_FLAG_IS_PARAM)) {
            id->local_num = scope->num_locals++;
        }
    }


    for (int i = 0; i < scope->id_info_len; i++) {
        id_info_t *id = &scope->id_info[i];



        if (id->kind == ID_INFO_KIND_CELL && !(id->flags & ID_FLAG_IS_PARAM)) {
            id->local_num = scope->num_locals;
            scope->num_locals += 1;
        }
    }



    if (scope->parent != 
# 3398 "../py/compile.c" 3 4
                        ((void *)0)
# 3398 "../py/compile.c"
                            ) {
        int num_free = 0;
        for (int i = 0; i < scope->parent->id_info_len; i++) {
            id_info_t *id = &scope->parent->id_info[i];
            if (id->kind == ID_INFO_KIND_CELL || id->kind == ID_INFO_KIND_FREE) {
                for (int j = 0; j < scope->id_info_len; j++) {
                    id_info_t *id2 = &scope->id_info[j];
                    if (id2->kind == ID_INFO_KIND_FREE && id->qst == id2->qst) {
                        
# 3406 "../py/compile.c" 3
                       ((
# 3406 "../py/compile.c"
                       !(id2->flags & ID_FLAG_IS_PARAM)
# 3406 "../py/compile.c" 3
                       ) ? (void)0 : __assert_func ("../py/compile.c", 3406, __func__, 
# 3406 "../py/compile.c"
                       "!(id2->flags & ID_FLAG_IS_PARAM)"
# 3406 "../py/compile.c" 3
                       ))
# 3406 "../py/compile.c"
                                                               ;

                        id2->local_num = num_free;
                        num_free += 1;
                    }
                }
            }
        }

        if (num_free > 0) {
            for (int i = 0; i < scope->id_info_len; i++) {
                id_info_t *id = &scope->id_info[i];
                if (id->kind != ID_INFO_KIND_FREE || (id->flags & ID_FLAG_IS_PARAM)) {
                    id->local_num += num_free;
                }
            }
            scope->num_pos_args += num_free;
            scope->num_locals += num_free;
        }
    }
}


static

mp_raw_code_t *mp_compile_to_raw_code(mp_parse_tree_t *parse_tree, qstr source_file, 
# 3431 "../py/compile.c" 3 4
                                                                                    _Bool 
# 3431 "../py/compile.c"
                                                                                         is_repl) {

    compiler_t comp_state = {0};
    compiler_t *comp = &comp_state;

    comp->source_file = source_file;
    comp->is_repl = is_repl;
    comp->break_label = (0xffff);
    comp->continue_label = (0xffff);



    const uint emit_opt = (mp_state_ctx.vm.default_emit_opt);



    scope_t *module_scope = scope_new_and_link(comp, SCOPE_MODULE, parse_tree->root, emit_opt);


    emit_t *emit_bc = emit_bc_new();


    comp->emit = emit_bc;

    comp->emit_method_table = &emit_bc_method_table;

    uint max_num_labels = 0;
    for (scope_t *s = comp->scope_head; s != 
# 3458 "../py/compile.c" 3 4
                                            ((void *)0) 
# 3458 "../py/compile.c"
                                                 && comp->compile_error == (((mp_obj_t)(void*)0)); s = s->next) {





        {
            compile_scope(comp, s, MP_PASS_SCOPE);


            for (size_t i = 0; i < s->id_info_len; ++i) {
                id_info_t *id = &s->id_info[i];
                if (id->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {
                    scope_check_to_close_over(s, id);
                }
            }
        }


        if (comp->next_label > max_num_labels) {
            max_num_labels = comp->next_label;
        }
    }


    for (scope_t *s = comp->scope_head; s != 
# 3483 "../py/compile.c" 3 4
                                            ((void *)0) 
# 3483 "../py/compile.c"
                                                 && comp->compile_error == (((mp_obj_t)(void*)0)); s = s->next) {
        scope_compute_things(s);
    }


    emit_bc_set_max_num_labels(emit_bc, max_num_labels);



    emit_t *emit_native = 
# 3492 "../py/compile.c" 3 4
                         ((void *)0)
# 3492 "../py/compile.c"
                             ;

    for (scope_t *s = comp->scope_head; s != 
# 3494 "../py/compile.c" 3 4
                                            ((void *)0) 
# 3494 "../py/compile.c"
                                                 && comp->compile_error == (((mp_obj_t)(void*)0)); s = s->next) {
# 3520 "../py/compile.c"
        {



            switch (s->emit_options) {


                case MP_EMIT_OPT_NATIVE_PYTHON:
                case MP_EMIT_OPT_VIPER:
                    if (emit_native == 
# 3529 "../py/compile.c" 3 4
                                      ((void *)0)
# 3529 "../py/compile.c"
                                          ) {
                        emit_native = emit_native_arm_new(&comp->compile_error, &comp->next_label, max_num_labels);
                    }
                    comp->emit_method_table = &emit_native_arm_method_table;
                    comp->emit = emit_native;
                    break;


                default:
                    comp->emit = emit_bc;

                    comp->emit_method_table = &emit_bc_method_table;

                    break;
            }


            compile_scope(comp, s, MP_PASS_STACK_SIZE);


            if (comp->compile_error == (((mp_obj_t)(void*)0))) {
                compile_scope(comp, s, MP_PASS_CODE_SIZE);
            }


            if (comp->compile_error == (((mp_obj_t)(void*)0))) {
                compile_scope(comp, s, MP_PASS_EMIT);
            }
        }
    }

    if (comp->compile_error != (((mp_obj_t)(void*)0))) {


        compile_error_set_line(comp, comp->scope_cur->pn);

        mp_obj_exception_add_traceback(comp->compile_error, comp->source_file,
            comp->compile_error_line, comp->scope_cur->simple_name);
    }



    emit_bc_free(emit_bc);

    if (emit_native != 
# 3573 "../py/compile.c" 3 4
                      ((void *)0)
# 3573 "../py/compile.c"
                          ) {
        emit_native_arm_free(emit_native);
    }
# 3584 "../py/compile.c"
    mp_parse_tree_clear(parse_tree);


    mp_raw_code_t *outer_raw_code = module_scope->raw_code;
    for (scope_t *s = module_scope; s;) {
        scope_t *next = s->next;
        scope_free(s);
        s = next;
    }

    if (comp->compile_error != (((mp_obj_t)(void*)0))) {
        nlr_jump(((void*)comp->compile_error));
    } else {
        return outer_raw_code;
    }
}

mp_obj_t mp_compile(mp_parse_tree_t *parse_tree, qstr source_file, 
# 3601 "../py/compile.c" 3 4
                                                                  _Bool 
# 3601 "../py/compile.c"
                                                                       is_repl) {
    mp_raw_code_t *rc = mp_compile_to_raw_code(parse_tree, source_file, is_repl);

    return mp_make_function_from_raw_code(rc, (((mp_obj_t)(void*)0)), (((mp_obj_t)(void*)0)));
}
# 0 "build/genhdr/moduledefs.h"
# 1 "/home/neo/Documents/Code/NumWorks/Upsilon-External-KhiCAS-docker/apps/KhiCAS/src/micropython-1.12/numworks//"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "build/genhdr/moduledefs.h"
# 11 "build/genhdr/moduledefs.h"
    extern const struct _mp_obj_module_t ulab_user_cmodule;
